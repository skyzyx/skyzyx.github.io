{
    "data": {
        
        
        "count": 1,
        "items": [
            
            {
    "kind": "page",
    "title": "Creating Smaller Docker Containers for Your Apps",
    "description": "When it comes to Docker containers, the smaller, the better.",
    "summary": {
        "content": "When it comes to Docker containers, the smaller, the better. Smaller containers are easier to work with, deploy faster, and tend to have fewer security vulnerabilities. This piece is part of a larger series on Engineering for Site Reliability, specifically Docker. Big is Bad I worked at WePay during the transition from a monolithic application in the datacenter to a series of microservices running in the cloud. I spent a lot of time working on the Vagrant-based CentOS development environment for the monolith, and also started maintaining a custom CentOS base image in Google Cloud.",
        "isTruncated": true
    },
    "published": "2018-08-16T16:27:52Z",
    "updated": "2019-02-10T21:35:12-08:00",
    "permalink": "https://ryanparman.com/posts/2018/creating-smaller-docker-containers-for-your-apps/",
    "relativePermalink": "/posts/2018/creating-smaller-docker-containers-for-your-apps/",
    "aliases": ["/2018/08/16/creating-very-small-docker-containers-for-php-apps"],
    "images": ["https://cdn.ryanparman.com/hugo/posts/2018/docker-logo.jpg", "https://cdn.ryanparman.com/hugo/headers/docker/dockerconeu.jpg"],
    "videos": [],
    "categories": ["Engineering for Site Reliability"],
    "tags": ["docker", "alpine linux", "centos", "ubuntu", "php", "nginx", "composer", "pip", "npm", "java", "glibc", "musl", "cve"],
    "series": ["Engineering for Site Reliability"],
    "keywords": [],
    "meta": {
        "wordCount": 1980,
        "readingTime": "10 minutes",
        "language": "en",
        "isDraft": false,
        "isHome": false,
        "isNode": false,
        "isPage": true,
        "isTranslated": false
    },
    "sourceFile": {
        "path": "posts/2018/20180816-creating-smaller-docker-containers-for-your-apps.md",
        "logicalName": "20180816-creating-smaller-docker-containers-for-your-apps.md",
        "translationBaseName": "20180816-creating-smaller-docker-containers-for-your-apps",
        "baseFileName": "20180816-creating-smaller-docker-containers-for-your-apps",
        "ext": "md",
        "lang": "en",
        "dir": "posts/2018/"
    },
    "content": {
        "tableOfContents": "\u003cnav id=\"TableOfContents\"\u003e\n  \u003cul\u003e\n    \u003cli\u003e\u003ca href=\"#big-is-bad\"\u003eBig is Bad\u003c/a\u003e\u003c/li\u003e\n    \u003cli\u003e\u003ca href=\"#smaller-is-better\"\u003eSmaller is better\u003c/a\u003e\n      \u003cul\u003e\n        \u003cli\u003e\u003ca href=\"#use-alpine-linux\"\u003eUse Alpine Linux\u003c/a\u003e\u003c/li\u003e\n        \u003cli\u003e\u003ca href=\"#learn-to-love-the-layer-cache\"\u003eLearn to love the layer cache\u003c/a\u003e\u003c/li\u003e\n        \u003cli\u003e\u003ca href=\"#installed-dependencies-should-be-runtime-only\"\u003eInstalled dependencies should be runtime-only\u003c/a\u003e\u003c/li\u003e\n        \u003cli\u003e\u003ca href=\"#flattening-your-base-images\"\u003eFlattening your (base) images\u003c/a\u003e\u003c/li\u003e\n      \u003c/ul\u003e\n    \u003c/li\u003e\n    \u003cli\u003e\u003ca href=\"#reduced-security-vulnerabilities\"\u003eReduced security vulnerabilities\u003c/a\u003e\u003c/li\u003e\n    \u003cli\u003e\u003ca href=\"#conclusion\"\u003eConclusion\u003c/a\u003e\u003c/li\u003e\n  \u003c/ul\u003e\n\u003c/nav\u003e",
        "html":"\u003cp itemprop=\"description\" class=\"f5 f4-m f3-l mt0 lh-copy p-summary entry-summary\"\u003e\nWhen it comes to Docker containers, the smaller, the better. Smaller containers are easier to work with, deploy faster, and tend to have fewer security vulnerabilities.\n\u003c/p\u003e\n\n\u003cdiv class=\"pa2-ns\"\u003e\n    \u003cpicture\u003e\u003csource type=\"image/webp\" srcset=\"https://cdn.ryanparman.com/hugo/posts/2018/docker-logo.webp\" alt=\"Docker Logo\" class=\"db fullimage\" decoding=\"async\"\u003e\n        \u003cimg src=\"https://cdn.ryanparman.com/hugo/posts/2018/docker-logo.jpg\" alt=\"Docker Logo\" class=\"db fullimage\" decoding=\"async\"\u003e\n    \u003c/picture\u003e\n    \u003cp class=\"f6 gray tc db\"\u003e\u003c/p\u003e\n\u003c/div\u003e\n\n\n\u003caside class=\"age aside container flex\"\u003e\u003cp\u003eThis piece is part of a larger series on \u003ca href=\"/series/engineering-for-site-reliability/\"\u003eEngineering for Site Reliability\u003c/a\u003e, specifically \u003cem\u003eDocker\u003c/em\u003e.\u003c/p\u003e\n\u003c/aside\u003e\n\n\u003ch2 id=\"big-is-bad\"\u003eBig is Bad\u003c/h2\u003e\n\u003cp\u003eI worked at \u003ca href=\"https://web.archive.org/web/20180816162752/https://wepay.com\"\u003eWePay\u003c/a\u003e during the transition from a monolithic application in the datacenter to a series of microservices running in the cloud. I spent a lot of time working on the Vagrant-based CentOS development environment for the monolith, and also started maintaining a custom CentOS base image in Google Cloud.\u003c/p\u003e\n\u003cp\u003eAs we were all learning about Docker, images, containers, and how it all worked together, the director of DevOps declared (unilaterally) that we should create Docker base images for the various languages we were using (PHP, Python, Java, Go), and they should all be built on a core CentOS 7 Docker image.\u003c/p\u003e\n\u003cp\u003eNow, many parts of this make sense:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003eHaving a base disk image for our hosts that builds-in all of the shared functionality we needed.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eHaving a base Docker image that every application referenced with \u003ccode\u003eFROM\u003c/code\u003e in their \u003ccode\u003eDockerfiles\u003c/code\u003e which included shared patterns for logging and metrics.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eHaving an optimized image for specific languages made it easier for developers using those languages to rapidly spin-up new application containers.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eBut there were also some major drawbacks to this approach.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003eDevelopers wanted to run \u003ccode\u003ecomposer install\u003c/code\u003e and \u003ccode\u003epip install requirements.txt\u003c/code\u003e from \u003cem\u003einside the container\u003c/em\u003e. This often required \u003cem\u003edevelopment dependencies\u003c/em\u003e to be installed in the containers.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eOne of our Java micro-service applications (CentOS 7 + Oracle Java + application code + development dependencies) clocked in at \u003cstrong\u003e1.8 GB\u003c/strong\u003e.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eOur build system was frequently buckling under the weight of caching and transferring large Docker images between its cluster and our Artifactory installation.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"pa2-ns\"\u003e\n    \u003cpicture\u003e\u003csource type=\"image/webp\" srcset=\"https://cdn.ryanparman.com/hugo/posts/2018/fat-guy.webp\" alt=\"Fat Guy eating a donut and cheese-whiz\" class=\"db fullimage\" decoding=\"async\"\u003e\n        \u003cimg src=\"https://cdn.ryanparman.com/hugo/posts/2018/fat-guy.jpg\" alt=\"Fat Guy eating a donut and cheese-whiz\" class=\"db fullimage\" decoding=\"async\"\u003e\n    \u003c/picture\u003e\n    \u003cp class=\"f6 gray tc db\"\u003e\u003c/p\u003e\n\u003c/div\u003e\n\n\u003cp\u003eNow, some of this can be chalked up to learning a new technology. Some of these are growing pains that were incurred at the same time as chunking apart our monolithic PHP app into Java/Python/Golang microservices. Some of this was hubris by people who made unilateral decisions. But we\u0026rsquo;d made it to the cloud. We\u0026rsquo;d made it to microservices. And I\u0026rsquo;m sure that WePay\u0026rsquo;s development practices have improved greatly over the last couple of years since I left.\u003c/p\u003e\n\u003ch2 id=\"smaller-is-better\"\u003eSmaller is better\u003c/h2\u003e\n\u003cp\u003eIn my current gig, my team has gone all-in with Docker, the AWS cloud, Infrastructure-as-Code, CI/CD practices, and the SRE support model. I\u0026rsquo;ll spend some time talking about these other topics in a future post, but I do want to talk about some process magic that makes it nearly effortless to deploy to Production multiple times per day with exceptionally little stress.\u003c/p\u003e\n\u003ch3 id=\"use-alpine-linux\"\u003eUse Alpine Linux\u003c/h3\u003e\n\u003cp\u003e\u003ca href=\"https://web.archive.org/web/20180816162752/https://alpinelinux.org\"\u003eAlpine Linux\u003c/a\u003e is the \u003cstrong\u003e5 MB\u003c/strong\u003e successor to \u003ca href=\"https://web.archive.org/web/20180816162752/https://www.busybox.net\"\u003eBusybox\u003c/a\u003e, which provides a few additional tools to Busybox’s \u003cstrong\u003e2 MB\u003c/strong\u003e image size.\u003c/p\u003e\n\u003cdiv class=\"pa2-ns\"\u003e\n    \u003cpicture\u003e\u003csource type=\"image/webp\" srcset=\"https://cdn.ryanparman.com/hugo/posts/2018/alpine.webp\" alt=\"Alpine Linux size compared to other Docker images.\" class=\"db fullimage\" decoding=\"async\"\u003e\n        \u003cimg src=\"https://cdn.ryanparman.com/hugo/posts/2018/alpine.png\" alt=\"Alpine Linux size compared to other Docker images.\" class=\"db fullimage\" decoding=\"async\"\u003e\n    \u003c/picture\u003e\n    \u003cp class=\"f6 gray tc db\"\u003e\u003c/p\u003e\n\u003c/div\u003e\n\n\u003cp\u003eGenerally speaking, \u003cstrong\u003eyou should always use Alpine Linux\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eI use the word \u0026ldquo;generally\u0026rdquo; because there are certain exceptions to this (otherwise) strong recommendation. The most important of which is that while larger Linux distributions which use the GNU’s \u003ca href=\"https://web.archive.org/web/20180816162752/https://www.gnu.org/software/libc/\"\u003eglibc\u003c/a\u003e library for the C Standard Library implementation, Alpine, Busybox, and others use a different library called \u003ca href=\"https://web.archive.org/web/20180816162752/https://musl-libc.org\"\u003emusl\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eYou can take a look at the \u003ca href=\"https://web.archive.org/web/20180816162752/https://wiki.musl-libc.org/functional-differences-from-glibc.html\"\u003edifferences between musl and glibc\u003c/a\u003e, but the part that matters to you is that there is \u003cem\u003esome\u003c/em\u003e software that exists which depends on the non-standard parts of glibc that haven\u0026rsquo;t been implemented in musl yet. What this means, practically speaking, are that things like the \u003ca href=\"https://web.archive.org/web/20180816162752/https://bugs.php.net/74982\"\u003e\u003ccode\u003e%P\u003c/code\u003e marker for \u003ccode\u003estrftime()\u003c/code\u003e doesn\u0026rsquo;t work as documented\u003c/a\u003e.\u003c/p\u003e\n\u003ch3 id=\"learn-to-love-the-layer-cache\"\u003eLearn to love the layer cache\u003c/h3\u003e\n\u003cp\u003eDocker images use \u003cem\u003elayers\u003c/em\u003e to overlay newer changes over previous changes using a technology called \u003ca href=\"https://web.archive.org/web/20180816162752/https://en.wikipedia.org/wiki/UnionFS\"\u003eUnionFS\u003c/a\u003e. This works similarly to Git, where all of the changes that ever happened are still inside the repository, but when you pull the \u003ccode\u003emaster\u003c/code\u003e branch, you\u0026rsquo;re pulling down dozens (or \u003cem\u003ehundreds\u003c/em\u003e, or \u003cem\u003ethousands\u003c/em\u003e) of layers that all need to resolve into the current state of the branch.\u003c/p\u003e\n\u003cp\u003eWith Docker, each of these layers is introduced by the \u003ca href=\"https://web.archive.org/web/20180816162752/https://docs.docker.com/engine/reference/builder/#run\"\u003e\u003ccode\u003eRUN\u003c/code\u003e statement\u003c/a\u003e inside a \u003ccode\u003eDockerfile\u003c/code\u003e.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4\"\u003e\u003ccode class=\"language-Dockerfile\" data-lang=\"Dockerfile\"\u003e\u003cspan style=\"color:#66d9ef\"\u003eFROM\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e nginx:1.15.1-alpine\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eENV\u003c/span\u003e RUNTIME_DEPS ca-certificates curl\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eRUN\u003c/span\u003e echo \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;http://dl-cdn.alpinelinux.org/alpine/v3.7/main\u0026#34;\u003c/span\u003e \u0026gt;\u0026gt; /etc/apk/repositories\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eRUN\u003c/span\u003e apk upgrade --no-cache --update\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eRUN\u003c/span\u003e apk add --no-cache --virtual .runtime-deps $RUNTIME_DEPS\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eRUN\u003c/span\u003e chmod -Rf \u003cspan style=\"color:#ae81ff\"\u003e0777\u003c/span\u003e /var/log\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\u003c/span\u003e...\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eIf a change is made to an earlier layer, then the layer cache is invalidated for all of the later layers, and those later layers need to be rebuilt. (Because of this, it\u0026rsquo;s always a good idea to put \u003cem\u003einfrequently\u003c/em\u003e changed commands first, and \u003cem\u003emore frequently\u003c/em\u003e changed commands last.)\u003c/p\u003e\n\u003cp\u003eUnfortunately, many people (including myself) read that Docker image layers have filesize overhead built into them. In order to make your containers smaller, you should combine all of your commands into a single \u003ccode\u003eRUN\u003c/code\u003e statement. The side effect is that any time you need to change \u003cem\u003eanything\u003c/em\u003e inside that \u003ccode\u003eRUN\u003c/code\u003e statement, Docker needs to rebuild everything from scratch — since it\u0026rsquo;s all in the same layer (which changed).\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4\"\u003e\u003ccode class=\"language-Dockerfile\" data-lang=\"Dockerfile\"\u003e\u003cspan style=\"color:#66d9ef\"\u003eFROM\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e nginx:1.15.1-alpine\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eENV\u003c/span\u003e RUNTIME_DEPS ca-certificates curl\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eRUN\u003c/span\u003e echo \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;http://dl-cdn.alpinelinux.org/alpine/v3.7/main\u0026#34;\u003c/span\u003e \u0026gt;\u0026gt; /etc/apk/repositories \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e    apk upgrade --no-cache --update \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e    apk add --no-cache --virtual .runtime-deps $RUNTIME_DEPS \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e    chmod -Rf \u003cspan style=\"color:#ae81ff\"\u003e0777\u003c/span\u003e /var/log\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\u003c/span\u003e...\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eBy leveraging the \u003ccode\u003eRUN\u003c/code\u003e statement as it was intended, you get to take advantage of faster re-build times by leveraging the \u003cem\u003elayer cache\u003c/em\u003e. This means that any layers (e.g., \u003ccode\u003eRUN\u003c/code\u003e statements) which haven\u0026rsquo;t changed since the last build do not need to be built again!\u003c/p\u003e\n\u003cp\u003eYes, your \u003cem\u003edevelopment\u003c/em\u003e Docker image may be a little larger, but we will address this later in this post.\u003c/p\u003e\n\u003ch3 id=\"installed-dependencies-should-be-runtime-only\"\u003eInstalled dependencies should be runtime-only\u003c/h3\u003e\n\u003cp\u003eThis is the one that kills me the most because it can be so wasteful, and it stems from not understanding how to use the tools in your toolbox.\u003c/p\u003e\n\u003cp\u003eFirstly, use a \u003ca href=\"https://web.archive.org/web/20180816162752/https://docs.docker.com/engine/reference/builder/#dockerignore-file\"\u003e\u003ccode\u003e.dockerignore\u003c/code\u003e file\u003c/a\u003e. Again, this is very similar to how a \u003ccode\u003e.gitignore\u003c/code\u003e file works — you don\u0026rsquo;t need everything you use for development to end up inside your Docker image, so use \u003ccode\u003e.dockerignore\u003c/code\u003e to avoid development dependencies.\u003c/p\u003e\n\u003cp\u003eYou never need your \u003ccode\u003e.git/\u003c/code\u003e directory to be copied into a Docker image. Once you\u0026rsquo;ve resolved your application dependencies, you also don\u0026rsquo;t need your \u003ccode\u003ecomposer.json\u003c/code\u003e, \u003ccode\u003epackage.json\u003c/code\u003e, \u003ccode\u003erequirements.txt\u003c/code\u003e, or other package manager definitions in there. You only need your vendored code. (Even then, you don\u0026rsquo;t need the tests for the vendored code either, most of the time. You should ignore those as well.)\u003c/p\u003e\n\u003cp\u003eSome dependencies need to build binaries for the OS they\u0026rsquo;re running inside of. For example, Node.js apps often rely on \u003cem\u003eOniguruma\u003c/em\u003e. Many Python applications rely on \u003cem\u003eMySQLdb\u003c/em\u003e. Both of these require that you install compilation tools and compile them on the OS that they run in.\u003c/p\u003e\n\u003cp\u003eSome companies solve this problem by \u003cem\u003einstalling GCC inside the Docker image\u003c/em\u003e.\u003c/p\u003e\n\u003cdiv class=\"pa2-ns\"\u003e\n    \u003cpicture\u003e\u003csource type=\"video/mp4\" srcset=\"https://cdn.ryanparman.com/hugo/posts/2018/mcfly-confused.mp4\" alt=\"Marty McFly looking very confused.\" class=\"db fullimage\" decoding=\"async\"\u003e\u003csource type=\"image/webp\" srcset=\"https://cdn.ryanparman.com/hugo/posts/2018/mcfly-confused.webp\" alt=\"Marty McFly looking very confused.\" class=\"db fullimage\" decoding=\"async\"\u003e\n        \u003cimg src=\"https://cdn.ryanparman.com/hugo/posts/2018/mcfly-confused.gif\" alt=\"Marty McFly looking very confused.\" class=\"db fullimage\" decoding=\"async\"\u003e\n    \u003c/picture\u003e\n    \u003cp class=\"f6 gray tc db\"\u003e\u003c/p\u003e\n\u003c/div\u003e\n\n\u003cp\u003eA better solution is to have \u003cem\u003ebuild-time\u003c/em\u003e and \u003cem\u003erun-time\u003c/em\u003e dependencies, wherein you uninstall the build-time dependencies once you\u0026rsquo;re done with them.\u003c/p\u003e\n\u003cp\u003eHere is an example of a PHP app that includes Redis support and installs the New Relic agent extension.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4\"\u003e\u003ccode class=\"language-Dockerfile\" data-lang=\"Dockerfile\"\u003e\u003cspan style=\"color:#66d9ef\"\u003eFROM\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e php:7.2.8-fpm-alpine3.7\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e# Needed at build-time, then can be uninstalled.\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eENV\u003c/span\u003e BUILD_DEPS alpine-sdk coreutils wget git autoconf re2c\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e# Should remain inside the container for runtime purposes.\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eENV\u003c/span\u003e PERSISTENT_DEPS net-tools hiredis-dev gmp-dev\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e# PHP extensions to install.\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eENV\u003c/span\u003e INSTALL_EXTENSIONS gmp json opcache pdo pdo_mysql\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e# New Relic values.\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eENV\u003c/span\u003e NR_INSTALL_SILENT \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eENV\u003c/span\u003e NR_VERSION 8.0.0.204\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e# Update the packages in the container to their latest security patches.\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eRUN\u003c/span\u003e apk upgrade --no-cache --update\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e# Install your build-time and runtime dependencies.\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e# Give these groups of dependencies names like `.build-deps`\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e# and `.persistent-deps` that we can refer to later.\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eRUN\u003c/span\u003e apk add --no-cache --virtual .build-deps $BUILD_DEPS\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eRUN\u003c/span\u003e apk add --no-cache --virtual .persistent-deps $PERSISTENT_DEPS\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e# Install the PHP extensions we need from the PHP repository.\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e# https://github.com/php/php-src/tree/master/ext\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eRUN\u003c/span\u003e docker-php-ext-install $INSTALL_EXTENSIONS\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e# Install the New Relic agent extension for PHP.\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eRUN\u003c/span\u003e wget -O /tmp/newrelic-php5.tar.gz https://download.newrelic.com/php_agent/archive/$NR_VERSION/newrelic-php5-$NR_VERSION-linux-musl.tar.gz\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eRUN\u003c/span\u003e tar -zxvf /tmp/newrelic-php5.tar.gz -C /usr/local/lib\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eRUN\u003c/span\u003e /usr/local/lib/newrelic*/newrelic-install install\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eRUN\u003c/span\u003e rm /usr/local/etc/php/conf.d/newrelic.ini\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e# Install the phpiredis extension for PHP.\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eRUN\u003c/span\u003e git clone https://github.com/nrk/phpiredis.git \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e cd phpiredis \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e phpize \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e ./configure --enable-phpiredis \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e make \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e make install\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e# Uninstall the grouping of dependencies called `.build-deps`.\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eRUN\u003c/span\u003e apk del .build-deps\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\u003c/span\u003e...\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"flattening-your-base-images\"\u003eFlattening your (base) images\u003c/h3\u003e\n\u003cp\u003eFlattening your images is an extra step that you can take to make your images as small as possible. This is particularly useful if you are building/providing \u003cem\u003ebase\u003c/em\u003e images for other people to consume downstream.\u003c/p\u003e\n\u003cp\u003eAs Thomas Uhrig \u003ca href=\"https://web.archive.org/web/20180816162752/https://tuhrig.de/flatten-a-docker-container-or-image/\"\u003ewrites\u003c/a\u003e:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eWe can use this mechanism to flatten and shrink a Docker container. If we save an image to the disk, its whole history will be preserved, but if we export a container, its history gets lost and the resulting tarball will be much smaller.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"color:#75715e\"\u003e# Launch the container from a Docker image\u003c/span\u003e\ndocker run \u0026lt;image\u0026gt; --detach\n\n\u003cspan style=\"color:#75715e\"\u003e# Export the running container to a tarball\u003c/span\u003e\ndocker export \u0026lt;container\u0026gt; \u0026gt; /tmp/docker-image.tar\n \n\u003cspan style=\"color:#75715e\"\u003e# Import it back into Docker\u003c/span\u003e\ncat /tmp/docker-image.tar | docker import - php-fpm:without-layers\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eBy running a container and exporting the data as a tarball, you can remove all of the intermediate layers and history from the final image, removing filesize overhead and reducing the overall image size.\u003c/p\u003e\n\u003cp\u003eAt the time of this writing, the latest version of \u003ca href=\"https://web.archive.org/web/20180816162752/https://store.docker.com/images/php\"\u003ePHP is 7.2.8\u003c/a\u003e (actually, 7.2.9 was cut yesterday, but the updated image hasn\u0026rsquo;t been released yet), which builds on top of the \u003ca href=\"https://web.archive.org/web/20180816162752/https://store.docker.com/images/alpine\"\u003eAlpine Linux 3.7\u003c/a\u003e image.\u003c/p\u003e\n\u003cp\u003eThe Alpine Linux image clocks in at just under \u003cstrong\u003e5 MB\u003c/strong\u003e. The PHP image adds a few layers, and brings things up to \u003cstrong\u003e78 MB\u003c/strong\u003e. So far, both of these are smaller than the base CentOS or Ubuntu images.\u003c/p\u003e\n\u003cp\u003eOur application includes the New Relic agent for PHP, a few extensions, our application code, and our Composer \u003ccode\u003evendor\u003c/code\u003e directory (without dev-dependencies).\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003ecomposer install --prefer-dist --no-dev\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eWe \u003cem\u003eshould\u003c/em\u003e remove things like tests from our \u003ccode\u003evendor\u003c/code\u003e directory, but we haven\u0026rsquo;t done that yet at the time of this writing. With all of our (wonderfully cached) layers, this brings the decompressed image size to \u003cstrong\u003e408 MB\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eAfter stripping out the history and removing all of the individual layers from the image (via a process called \u003cem\u003eflattening\u003c/em\u003e), our final \u003cem\u003edecompressed\u003c/em\u003e image size is a mere \u003cstrong\u003e197 MB\u003c/strong\u003e in size.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4\"\u003e\u003ccode class=\"language-plain\" data-lang=\"plain\"\u003e$ docker images\n\nREPOSITORY     TAG                   IMAGE ID       CREATED          SIZE\nalpine         3.7                   791c3e2ebfcb   5 weeks ago      4.2MB\nphp            7.2.7-fpm-alpine3.7   9cf17fea14c0   5 weeks ago      78.3MB\nphp-fpm        with-layers           94121f6a6537   29 seconds ago   408MB\nphp-fpm        without-layers        8468ea1ee874   4 seconds ago    197MB\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eWhen you push your image up to a Docker registry (e.g., Docker Hub, Amazon ECR, Google Container Registry, Quay.io, Artifactory), the images will be compressed. Our final Docker image, compressed-at-rest, is only \u003cstrong\u003e72 MB\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eA small, 72 MB Docker image for our application is small and easy enough to push into our CI/CD pipeline in only a few seconds, and puts very little network or storage strain on our internal systems. It\u0026rsquo;s fast to download into my local development environment, and every step of the development and build processes are automated.\u003c/p\u003e\n\u003ch2 id=\"reduced-security-vulnerabilities\"\u003eReduced security vulnerabilities\u003c/h2\u003e\n\u003cp\u003eOver my career, I\u0026rsquo;ve observed that engineers view the topic of \u0026ldquo;security\u0026rdquo; primarily through the lense of their job role.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eApplication engineers tend to view security as things like XSS vulnerabilities and SQL injections.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eSystem engineers tend to view security as things like CVEs and intrusions.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eSecurity engineers tend to see those things + TLS certificates + CIS Benchmarks + secrets management and rotation + user permissions + …\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIn this context, I\u0026rsquo;m referring primarily to \u003cem\u003esecurity vulnerabilties\u003c/em\u003e along the lines of \u003ca href=\"https://web.archive.org/web/20180816162752/http://heartbleed.com\"\u003eHeartbleed\u003c/a\u003e, \u003ca href=\"https://web.archive.org/web/20180816162752/https://nvd.nist.gov/vuln/detail/CVE-2014-6271\"\u003eShellShock\u003c/a\u003e, and \u003ca href=\"https://web.archive.org/web/20180816162752/https://httpoxy.org\"\u003ehttpoxy\u003c/a\u003e. Because there is so little software installed by default, the \u003cem\u003eattack surface\u003c/em\u003e is substantially reduced — oftentimes to the point where there are zero known vulnerabilities anywhere in your application container.\u003c/p\u003e\n\u003cdiv class=\"pa2-ns pv4-l\"\u003e\n\t\u003camp-img src=\"https://cdn.ryanparman.com/hugo/posts/2018/heartbleed.png\" layout=\"responsive\" width=\"\" height=\"\"\u003e\u003c/amp-img\u003e\n    \u003cp class=\"f6 gray tc db\"\u003eLogo for the Heartbleed vulnerability.\u003c/p\u003e\n\u003c/div\u003e\n\n\u003cp\u003eThis is entirely unheard of in CentOS, Ubuntu, and other larger distributions. As a matter of fact, when our application went live and we underwent review with the security team, they scanned our hosts and containers with zero unpatched vulnerabilities and thought that the scan was bad or their software was broken.\u003c/p\u003e\n\u003ch2 id=\"conclusion\"\u003eConclusion\u003c/h2\u003e\n\u003cp\u003eThe most important things to take away from this are:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eBig Docker images are a bad thing.\u003c/li\u003e\n\u003cli\u003eUse Alpine Linux. Seriously.\u003c/li\u003e\n\u003cli\u003eRemove your build-time dependencies.\u003c/li\u003e\n\u003cli\u003eFlatten your images if you\u0026rsquo;re sharing them.\u003c/li\u003e\n\u003cli\u003eThe less software that is installed, the fewer security vulnerabilities there will be.\u003c/li\u003e\n\u003cli\u003eMaking your images as small as possible can greatly reduce the burden on the rest of your infrastructure.\u003c/li\u003e\n\u003c/ol\u003e\n",
        "plain":"When it comes to Docker containers, the smaller, the better. Smaller containers are easier to work with, deploy faster, and tend to have fewer security vulnerabilities.   This piece is part of a larger series on Engineering for Site Reliability, specifically Docker.\n Big is Bad I worked at WePay during the transition from a monolithic application in the datacenter to a series of microservices running in the cloud. I spent a lot of time working on the Vagrant-based CentOS development environment for the monolith, and also started maintaining a custom CentOS base image in Google Cloud.\nAs we were all learning about Docker, images, containers, and how it all worked together, the director of DevOps declared (unilaterally) that we should create Docker base images for the various languages we were using (PHP, Python, Java, Go), and they should all be built on a core CentOS 7 Docker image.\nNow, many parts of this make sense:\n  Having a base disk image for our hosts that builds-in all of the shared functionality we needed.\n  Having a base Docker image that every application referenced with FROM in their Dockerfiles which included shared patterns for logging and metrics.\n  Having an optimized image for specific languages made it easier for developers using those languages to rapidly spin-up new application containers.\n  But there were also some major drawbacks to this approach.\n  Developers wanted to run composer install and pip install requirements.txt from inside the container. This often required development dependencies to be installed in the containers.\n  One of our Java micro-service applications (CentOS 7 + Oracle Java + application code + development dependencies) clocked in at 1.8 GB.\n  Our build system was frequently buckling under the weight of caching and transferring large Docker images between its cluster and our Artifactory installation.\n    Now, some of this can be chalked up to learning a new technology. Some of these are growing pains that were incurred at the same time as chunking apart our monolithic PHP app into Java/Python/Golang microservices. Some of this was hubris by people who made unilateral decisions. But we\u0026rsquo;d made it to the cloud. We\u0026rsquo;d made it to microservices. And I\u0026rsquo;m sure that WePay\u0026rsquo;s development practices have improved greatly over the last couple of years since I left.\nSmaller is better In my current gig, my team has gone all-in with Docker, the AWS cloud, Infrastructure-as-Code, CI/CD practices, and the SRE support model. I\u0026rsquo;ll spend some time talking about these other topics in a future post, but I do want to talk about some process magic that makes it nearly effortless to deploy to Production multiple times per day with exceptionally little stress.\nUse Alpine Linux Alpine Linux is the 5 MB successor to Busybox, which provides a few additional tools to Busybox’s 2 MB image size.\n  Generally speaking, you should always use Alpine Linux.\nI use the word \u0026ldquo;generally\u0026rdquo; because there are certain exceptions to this (otherwise) strong recommendation. The most important of which is that while larger Linux distributions which use the GNU’s glibc library for the C Standard Library implementation, Alpine, Busybox, and others use a different library called musl.\nYou can take a look at the differences between musl and glibc, but the part that matters to you is that there is some software that exists which depends on the non-standard parts of glibc that haven\u0026rsquo;t been implemented in musl yet. What this means, practically speaking, are that things like the %P marker for strftime() doesn\u0026rsquo;t work as documented.\nLearn to love the layer cache Docker images use layers to overlay newer changes over previous changes using a technology called UnionFS. This works similarly to Git, where all of the changes that ever happened are still inside the repository, but when you pull the master branch, you\u0026rsquo;re pulling down dozens (or hundreds, or thousands) of layers that all need to resolve into the current state of the branch.\nWith Docker, each of these layers is introduced by the RUN statement inside a Dockerfile.\nFROMnginx:1.15.1-alpineENV RUNTIME_DEPS ca-certificates curlRUN echo \u0026#34;http://dl-cdn.alpinelinux.org/alpine/v3.7/main\u0026#34; \u0026gt;\u0026gt; /etc/apk/repositoriesRUN apk upgrade --no-cache --updateRUN apk add --no-cache --virtual .runtime-deps $RUNTIME_DEPSRUN chmod -Rf 0777 /var/log...If a change is made to an earlier layer, then the layer cache is invalidated for all of the later layers, and those later layers need to be rebuilt. (Because of this, it\u0026rsquo;s always a good idea to put infrequently changed commands first, and more frequently changed commands last.)\nUnfortunately, many people (including myself) read that Docker image layers have filesize overhead built into them. In order to make your containers smaller, you should combine all of your commands into a single RUN statement. The side effect is that any time you need to change anything inside that RUN statement, Docker needs to rebuild everything from scratch — since it\u0026rsquo;s all in the same layer (which changed).\nFROMnginx:1.15.1-alpineENV RUNTIME_DEPS ca-certificates curlRUN echo \u0026#34;http://dl-cdn.alpinelinux.org/alpine/v3.7/main\u0026#34; \u0026gt;\u0026gt; /etc/apk/repositories \u0026amp;\u0026amp; \\  apk upgrade --no-cache --update \u0026amp;\u0026amp; \\  apk add --no-cache --virtual .runtime-deps $RUNTIME_DEPS \u0026amp;\u0026amp; \\  chmod -Rf 0777 /var/log...By leveraging the RUN statement as it was intended, you get to take advantage of faster re-build times by leveraging the layer cache. This means that any layers (e.g., RUN statements) which haven\u0026rsquo;t changed since the last build do not need to be built again!\nYes, your development Docker image may be a little larger, but we will address this later in this post.\nInstalled dependencies should be runtime-only This is the one that kills me the most because it can be so wasteful, and it stems from not understanding how to use the tools in your toolbox.\nFirstly, use a .dockerignore file. Again, this is very similar to how a .gitignore file works — you don\u0026rsquo;t need everything you use for development to end up inside your Docker image, so use .dockerignore to avoid development dependencies.\nYou never need your .git/ directory to be copied into a Docker image. Once you\u0026rsquo;ve resolved your application dependencies, you also don\u0026rsquo;t need your composer.json, package.json, requirements.txt, or other package manager definitions in there. You only need your vendored code. (Even then, you don\u0026rsquo;t need the tests for the vendored code either, most of the time. You should ignore those as well.)\nSome dependencies need to build binaries for the OS they\u0026rsquo;re running inside of. For example, Node.js apps often rely on Oniguruma. Many Python applications rely on MySQLdb. Both of these require that you install compilation tools and compile them on the OS that they run in.\nSome companies solve this problem by installing GCC inside the Docker image.\n  A better solution is to have build-time and run-time dependencies, wherein you uninstall the build-time dependencies once you\u0026rsquo;re done with them.\nHere is an example of a PHP app that includes Redis support and installs the New Relic agent extension.\nFROMphp:7.2.8-fpm-alpine3.7# Needed at build-time, then can be uninstalled.ENV BUILD_DEPS alpine-sdk coreutils wget git autoconf re2c# Should remain inside the container for runtime purposes.ENV PERSISTENT_DEPS net-tools hiredis-dev gmp-dev# PHP extensions to install.ENV INSTALL_EXTENSIONS gmp json opcache pdo pdo_mysql# New Relic values.ENV NR_INSTALL_SILENT 1ENV NR_VERSION 8.0.0.204# Update the packages in the container to their latest security patches.RUN apk upgrade --no-cache --update# Install your build-time and runtime dependencies.# Give these groups of dependencies names like `.build-deps`# and `.persistent-deps` that we can refer to later.RUN apk add --no-cache --virtual .build-deps $BUILD_DEPSRUN apk add --no-cache --virtual .persistent-deps $PERSISTENT_DEPS# Install the PHP extensions we need from the PHP repository.# https://github.com/php/php-src/tree/master/extRUN docker-php-ext-install $INSTALL_EXTENSIONS# Install the New Relic agent extension for PHP.RUN wget -O /tmp/newrelic-php5.tar.gz https://download.newrelic.com/php_agent/archive/$NR_VERSION/newrelic-php5-$NR_VERSION-linux-musl.tar.gzRUN tar -zxvf /tmp/newrelic-php5.tar.gz -C /usr/local/libRUN /usr/local/lib/newrelic*/newrelic-install installRUN rm /usr/local/etc/php/conf.d/newrelic.ini# Install the phpiredis extension for PHP.RUN git clone https://github.com/nrk/phpiredis.git \u0026amp;\u0026amp; cd phpiredis \u0026amp;\u0026amp; phpize \u0026amp;\u0026amp; ./configure --enable-phpiredis \u0026amp;\u0026amp; make \u0026amp;\u0026amp; make install# Uninstall the grouping of dependencies called `.build-deps`.RUN apk del .build-deps...Flattening your (base) images Flattening your images is an extra step that you can take to make your images as small as possible. This is particularly useful if you are building/providing base images for other people to consume downstream.\nAs Thomas Uhrig writes:\n We can use this mechanism to flatten and shrink a Docker container. If we save an image to the disk, its whole history will be preserved, but if we export a container, its history gets lost and the resulting tarball will be much smaller.\n # Launch the container from a Docker image docker run \u0026lt;image\u0026gt; --detach # Export the running container to a tarball docker export \u0026lt;container\u0026gt; \u0026gt; /tmp/docker-image.tar # Import it back into Docker cat /tmp/docker-image.tar | docker import - php-fpm:without-layers By running a container and exporting the data as a tarball, you can remove all of the intermediate layers and history from the final image, removing filesize overhead and reducing the overall image size.\nAt the time of this writing, the latest version of PHP is 7.2.8 (actually, 7.2.9 was cut yesterday, but the updated image hasn\u0026rsquo;t been released yet), which builds on top of the Alpine Linux 3.7 image.\nThe Alpine Linux image clocks in at just under 5 MB. The PHP image adds a few layers, and brings things up to 78 MB. So far, both of these are smaller than the base CentOS or Ubuntu images.\nOur application includes the New Relic agent for PHP, a few extensions, our application code, and our Composer vendor directory (without dev-dependencies).\ncomposer install --prefer-dist --no-dev We should remove things like tests from our vendor directory, but we haven\u0026rsquo;t done that yet at the time of this writing. With all of our (wonderfully cached) layers, this brings the decompressed image size to 408 MB.\nAfter stripping out the history and removing all of the individual layers from the image (via a process called flattening), our final decompressed image size is a mere 197 MB in size.\n$ docker images REPOSITORY TAG IMAGE ID CREATED SIZE alpine 3.7 791c3e2ebfcb 5 weeks ago 4.2MB php 7.2.7-fpm-alpine3.7 9cf17fea14c0 5 weeks ago 78.3MB php-fpm with-layers 94121f6a6537 29 seconds ago 408MB php-fpm without-layers 8468ea1ee874 4 seconds ago 197MB When you push your image up to a Docker registry (e.g., Docker Hub, Amazon ECR, Google Container Registry, Quay.io, Artifactory), the images will be compressed. Our final Docker image, compressed-at-rest, is only 72 MB.\nA small, 72 MB Docker image for our application is small and easy enough to push into our CI/CD pipeline in only a few seconds, and puts very little network or storage strain on our internal systems. It\u0026rsquo;s fast to download into my local development environment, and every step of the development and build processes are automated.\nReduced security vulnerabilities Over my career, I\u0026rsquo;ve observed that engineers view the topic of \u0026ldquo;security\u0026rdquo; primarily through the lense of their job role.\n  Application engineers tend to view security as things like XSS vulnerabilities and SQL injections.\n  System engineers tend to view security as things like CVEs and intrusions.\n  Security engineers tend to see those things + TLS certificates + CIS Benchmarks + secrets management and rotation + user permissions + …\n  In this context, I\u0026rsquo;m referring primarily to security vulnerabilties along the lines of Heartbleed, ShellShock, and httpoxy. Because there is so little software installed by default, the attack surface is substantially reduced — oftentimes to the point where there are zero known vulnerabilities anywhere in your application container.\n Logo for the Heartbleed vulnerability.\n This is entirely unheard of in CentOS, Ubuntu, and other larger distributions. As a matter of fact, when our application went live and we underwent review with the security team, they scanned our hosts and containers with zero unpatched vulnerabilities and thought that the scan was bad or their software was broken.\nConclusion The most important things to take away from this are:\n Big Docker images are a bad thing. Use Alpine Linux. Seriously. Remove your build-time dependencies. Flatten your images if you\u0026rsquo;re sharing them. The less software that is installed, the fewer security vulnerabilities there will be. Making your images as small as possible can greatly reduce the burden on the rest of your infrastructure.  ",
        "source":"\n{{\u003cdescription\u003e}}\nWhen it comes to Docker containers, the smaller, the better. Smaller containers are easier to work with, deploy faster, and tend to have fewer security vulnerabilities.\n{{\u003c/description\u003e}}\n\n{{\u003cfullimage src=\"https://cdn.ryanparman.com/hugo/posts/2018/docker-logo.jpg\" alt=\"Docker Logo\"\u003e}}\n\n{{% aside %}}\nThis piece is part of a larger series on [Engineering for Site Reliability](/series/engineering-for-site-reliability/), specifically _Docker_.\n{{% /aside %}}\n\n## Big is Bad\n\nI worked at [WePay]({{\u003c wayback \"https://wepay.com\" \u003e}}) during the transition from a monolithic application in the datacenter to a series of microservices running in the cloud. I spent a lot of time working on the Vagrant-based CentOS development environment for the monolith, and also started maintaining a custom CentOS base image in Google Cloud.\n\nAs we were all learning about Docker, images, containers, and how it all worked together, the director of DevOps declared (unilaterally) that we should create Docker base images for the various languages we were using (PHP, Python, Java, Go), and they should all be built on a core CentOS 7 Docker image.\n\nNow, many parts of this make sense:\n\n1. Having a base disk image for our hosts that builds-in all of the shared functionality we needed.\n\n1. Having a base Docker image that every application referenced with `FROM` in their `Dockerfiles` which included shared patterns for logging and metrics.\n\n1. Having an optimized image for specific languages made it easier for developers using those languages to rapidly spin-up new application containers.\n\nBut there were also some major drawbacks to this approach.\n\n1. Developers wanted to run `composer install` and `pip install requirements.txt` from _inside the container_. This often required _development dependencies_ to be installed in the containers.\n\n1. One of our Java micro-service applications (CentOS 7 + Oracle Java + application code + development dependencies) clocked in at **1.8 GB**.\n\n1. Our build system was frequently buckling under the weight of caching and transferring large Docker images between its cluster and our Artifactory installation.\n\n{{\u003cfullimage src=\"https://cdn.ryanparman.com/hugo/posts/2018/fat-guy.jpg\" alt=\"Fat Guy eating a donut and cheese-whiz\"\u003e}}\n\nNow, some of this can be chalked up to learning a new technology. Some of these are growing pains that were incurred at the same time as chunking apart our monolithic PHP app into Java/Python/Golang microservices. Some of this was hubris by people who made unilateral decisions. But we'd made it to the cloud. We'd made it to microservices. And I'm sure that WePay's development practices have improved greatly over the last couple of years since I left.\n\n## Smaller is better\n\nIn my current gig, my team has gone all-in with Docker, the AWS cloud, Infrastructure-as-Code, CI/CD practices, and the SRE support model. I'll spend some time talking about these other topics in a future post, but I do want to talk about some process magic that makes it nearly effortless to deploy to Production multiple times per day with exceptionally little stress.\n\n### Use Alpine Linux\n\n[Alpine Linux]({{\u003c wayback \"https://alpinelinux.org\" \u003e}}) is the **5 MB** successor to [Busybox]({{\u003c wayback \"https://www.busybox.net\" \u003e}}), which provides a few additional tools to Busybox’s **2 MB** image size.\n\n{{\u003cfullimage src=\"https://cdn.ryanparman.com/hugo/posts/2018/alpine.png\" alt=\"Alpine Linux size compared to other Docker images.\"\u003e}}\n\nGenerally speaking, **you should always use Alpine Linux**.\n\nI use the word \"generally\" because there are certain exceptions to this (otherwise) strong recommendation. The most important of which is that while larger Linux distributions which use the GNU’s [glibc]({{\u003c wayback \"https://www.gnu.org/software/libc/\" \u003e}}) library for the C Standard Library implementation, Alpine, Busybox, and others use a different library called [musl]({{\u003c wayback \"https://musl-libc.org\" \u003e}}).\n\nYou can take a look at the [differences between musl and glibc]({{\u003c wayback \"https://wiki.musl-libc.org/functional-differences-from-glibc.html\" \u003e}}), but the part that matters to you is that there is _some_ software that exists which depends on the non-standard parts of glibc that haven't been implemented in musl yet. What this means, practically speaking, are that things like the [`%P` marker for `strftime()` doesn't work as documented]({{\u003c wayback \"https://bugs.php.net/74982\" \u003e}}).\n\n### Learn to love the layer cache\n\nDocker images use _layers_ to overlay newer changes over previous changes using a technology called [UnionFS]({{\u003c wayback \"https://en.wikipedia.org/wiki/UnionFS\" \u003e}}). This works similarly to Git, where all of the changes that ever happened are still inside the repository, but when you pull the `master` branch, you're pulling down dozens (or _hundreds_, or _thousands_) of layers that all need to resolve into the current state of the branch.\n\nWith Docker, each of these layers is introduced by the [`RUN` statement]({{\u003c wayback \"https://docs.docker.com/engine/reference/builder/#run\" \u003e}}) inside a `Dockerfile`.\n\n```Dockerfile\nFROM nginx:1.15.1-alpine\n\nENV RUNTIME_DEPS ca-certificates curl\n\nRUN echo \"http://dl-cdn.alpinelinux.org/alpine/v3.7/main\" \u003e\u003e /etc/apk/repositories\nRUN apk upgrade --no-cache --update\nRUN apk add --no-cache --virtual .runtime-deps $RUNTIME_DEPS\nRUN chmod -Rf 0777 /var/log\n\n...\n```\n\nIf a change is made to an earlier layer, then the layer cache is invalidated for all of the later layers, and those later layers need to be rebuilt. (Because of this, it's always a good idea to put _infrequently_ changed commands first, and _more frequently_ changed commands last.)\n\nUnfortunately, many people (including myself) read that Docker image layers have filesize overhead built into them. In order to make your containers smaller, you should combine all of your commands into a single `RUN` statement. The side effect is that any time you need to change _anything_ inside that `RUN` statement, Docker needs to rebuild everything from scratch — since it's all in the same layer (which changed).\n\n```Dockerfile\nFROM nginx:1.15.1-alpine\n\nENV RUNTIME_DEPS ca-certificates curl\n\nRUN echo \"http://dl-cdn.alpinelinux.org/alpine/v3.7/main\" \u003e\u003e /etc/apk/repositories \u0026\u0026 \\\n    apk upgrade --no-cache --update \u0026\u0026 \\\n    apk add --no-cache --virtual .runtime-deps $RUNTIME_DEPS \u0026\u0026 \\\n    chmod -Rf 0777 /var/log\n\n...\n```\n\nBy leveraging the `RUN` statement as it was intended, you get to take advantage of faster re-build times by leveraging the _layer cache_. This means that any layers (e.g., `RUN` statements) which haven't changed since the last build do not need to be built again!\n\nYes, your _development_ Docker image may be a little larger, but we will address this later in this post.\n\n### Installed dependencies should be runtime-only\n\nThis is the one that kills me the most because it can be so wasteful, and it stems from not understanding how to use the tools in your toolbox.\n\nFirstly, use a [`.dockerignore` file]({{\u003c wayback \"https://docs.docker.com/engine/reference/builder/#dockerignore-file\" \u003e}}). Again, this is very similar to how a `.gitignore` file works — you don't need everything you use for development to end up inside your Docker image, so use `.dockerignore` to avoid development dependencies.\n\nYou never need your `.git/` directory to be copied into a Docker image. Once you've resolved your application dependencies, you also don't need your `composer.json`, `package.json`, `requirements.txt`, or other package manager definitions in there. You only need your vendored code. (Even then, you don't need the tests for the vendored code either, most of the time. You should ignore those as well.)\n\nSome dependencies need to build binaries for the OS they're running inside of. For example, Node.js apps often rely on _Oniguruma_. Many Python applications rely on _MySQLdb_. Both of these require that you install compilation tools and compile them on the OS that they run in.\n\nSome companies solve this problem by _installing GCC inside the Docker image_.\n\n{{\u003cfullimage src=\"https://cdn.ryanparman.com/hugo/posts/2018/mcfly-confused.gif\" mp4=true alt=\"Marty McFly looking very confused.\"\u003e}}\n\nA better solution is to have _build-time_ and _run-time_ dependencies, wherein you uninstall the build-time dependencies once you're done with them.\n\nHere is an example of a PHP app that includes Redis support and installs the New Relic agent extension.\n\n```Dockerfile\nFROM php:7.2.8-fpm-alpine3.7\n\n# Needed at build-time, then can be uninstalled.\nENV BUILD_DEPS alpine-sdk coreutils wget git autoconf re2c\n\n# Should remain inside the container for runtime purposes.\nENV PERSISTENT_DEPS net-tools hiredis-dev gmp-dev\n\n# PHP extensions to install.\nENV INSTALL_EXTENSIONS gmp json opcache pdo pdo_mysql\n\n# New Relic values.\nENV NR_INSTALL_SILENT 1\nENV NR_VERSION 8.0.0.204\n\n# Update the packages in the container to their latest security patches.\nRUN apk upgrade --no-cache --update\n\n# Install your build-time and runtime dependencies.\n# Give these groups of dependencies names like `.build-deps`\n# and `.persistent-deps` that we can refer to later.\nRUN apk add --no-cache --virtual .build-deps $BUILD_DEPS\nRUN apk add --no-cache --virtual .persistent-deps $PERSISTENT_DEPS\n\n# Install the PHP extensions we need from the PHP repository.\n# https://github.com/php/php-src/tree/master/ext\nRUN docker-php-ext-install $INSTALL_EXTENSIONS\n\n# Install the New Relic agent extension for PHP.\nRUN wget -O /tmp/newrelic-php5.tar.gz https://download.newrelic.com/php_agent/archive/$NR_VERSION/newrelic-php5-$NR_VERSION-linux-musl.tar.gz\nRUN tar -zxvf /tmp/newrelic-php5.tar.gz -C /usr/local/lib\nRUN /usr/local/lib/newrelic*/newrelic-install install\nRUN rm /usr/local/etc/php/conf.d/newrelic.ini\n\n# Install the phpiredis extension for PHP.\nRUN git clone https://github.com/nrk/phpiredis.git \u0026\u0026 cd phpiredis \u0026\u0026 phpize \u0026\u0026 ./configure --enable-phpiredis \u0026\u0026 make \u0026\u0026 make install\n\n# Uninstall the grouping of dependencies called `.build-deps`.\nRUN apk del .build-deps\n\n...\n```\n\n### Flattening your (base) images\n\nFlattening your images is an extra step that you can take to make your images as small as possible. This is particularly useful if you are building/providing _base_ images for other people to consume downstream.\n\nAs Thomas Uhrig [writes]({{\u003c wayback \"https://tuhrig.de/flatten-a-docker-container-or-image/\" \u003e}}):\n\n\u003e We can use this mechanism to flatten and shrink a Docker container. If we save an image to the disk, its whole history will be preserved, but if we export a container, its history gets lost and the resulting tarball will be much smaller.\n\n```bash\n# Launch the container from a Docker image\ndocker run \u003cimage\u003e --detach\n\n# Export the running container to a tarball\ndocker export \u003ccontainer\u003e \u003e /tmp/docker-image.tar\n \n# Import it back into Docker\ncat /tmp/docker-image.tar | docker import - php-fpm:without-layers\n```\n\nBy running a container and exporting the data as a tarball, you can remove all of the intermediate layers and history from the final image, removing filesize overhead and reducing the overall image size.\n\nAt the time of this writing, the latest version of [PHP is 7.2.8]({{\u003c wayback \"https://store.docker.com/images/php\" \u003e}}) (actually, 7.2.9 was cut yesterday, but the updated image hasn't been released yet), which builds on top of the [Alpine Linux 3.7]({{\u003c wayback \"https://store.docker.com/images/alpine\" \u003e}}) image.\n\nThe Alpine Linux image clocks in at just under **5 MB**. The PHP image adds a few layers, and brings things up to **78 MB**. So far, both of these are smaller than the base CentOS or Ubuntu images.\n\nOur application includes the New Relic agent for PHP, a few extensions, our application code, and our Composer `vendor` directory (without dev-dependencies).\n\n```bash\ncomposer install --prefer-dist --no-dev\n```\n\nWe _should_ remove things like tests from our `vendor` directory, but we haven't done that yet at the time of this writing. With all of our (wonderfully cached) layers, this brings the decompressed image size to **408 MB**.\n\nAfter stripping out the history and removing all of the individual layers from the image (via a process called _flattening_), our final _decompressed_ image size is a mere **197 MB** in size.\n\n```plain\n$ docker images\n\nREPOSITORY     TAG                   IMAGE ID       CREATED          SIZE\nalpine         3.7                   791c3e2ebfcb   5 weeks ago      4.2MB\nphp            7.2.7-fpm-alpine3.7   9cf17fea14c0   5 weeks ago      78.3MB\nphp-fpm        with-layers           94121f6a6537   29 seconds ago   408MB\nphp-fpm        without-layers        8468ea1ee874   4 seconds ago    197MB\n\n```\n\nWhen you push your image up to a Docker registry (e.g., Docker Hub, Amazon ECR, Google Container Registry, Quay.io, Artifactory), the images will be compressed. Our final Docker image, compressed-at-rest, is only **72 MB**.\n\nA small, 72 MB Docker image for our application is small and easy enough to push into our CI/CD pipeline in only a few seconds, and puts very little network or storage strain on our internal systems. It's fast to download into my local development environment, and every step of the development and build processes are automated.\n\n## Reduced security vulnerabilities\n\nOver my career, I've observed that engineers view the topic of \"security\" primarily through the lense of their job role.\n\n* Application engineers tend to view security as things like XSS vulnerabilities and SQL injections.\n\n* System engineers tend to view security as things like CVEs and intrusions.\n\n* Security engineers tend to see those things + TLS certificates + CIS Benchmarks + secrets management and rotation + user permissions + …\n\nIn this context, I'm referring primarily to _security vulnerabilties_ along the lines of [Heartbleed]({{\u003c wayback \"http://heartbleed.com\" \u003e}}), [ShellShock]({{\u003c wayback \"https://nvd.nist.gov/vuln/detail/CVE-2014-6271\" \u003e}}), and [httpoxy]({{\u003c wayback \"https://httpoxy.org\" \u003e}}). Because there is so little software installed by default, the _attack surface_ is substantially reduced — oftentimes to the point where there are zero known vulnerabilities anywhere in your application container.\n\n{{\u003cfullimage-noshadow src=\"https://cdn.ryanparman.com/hugo/posts/2018/heartbleed.png\" alt=\"Logo for the Heartbleed vulnerability.\" figure=\"Logo for the Heartbleed vulnerability.\"\u003e}}\n\nThis is entirely unheard of in CentOS, Ubuntu, and other larger distributions. As a matter of fact, when our application went live and we underwent review with the security team, they scanned our hosts and containers with zero unpatched vulnerabilities and thought that the scan was bad or their software was broken.\n\n## Conclusion\n\nThe most important things to take away from this are:\n\n1. Big Docker images are a bad thing.\n1. Use Alpine Linux. Seriously.\n1. Remove your build-time dependencies.\n1. Flatten your images if you're sharing them.\n1. The less software that is installed, the fewer security vulnerabilities there will be.\n1. Making your images as small as possible can greatly reduce the burden on the rest of your infrastructure.\n"},
    "links": {
        "prev": {"title": "Dear Nintendo, Part II", "permalink": "https://ryanparman.com/posts/2018/dear-nintendo-part-ii/"},
        "next": {"title": "Clueless Recruiters, Issue #8", "permalink": "https://ryanparman.com/posts/2018/clueless-recruiters-issue-8/"},
        "ignore": "me"
    }
}

            
        ]
    }
}
