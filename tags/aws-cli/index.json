{
    "data": {
        
        
        "taxonomy": "tag",
        "term": "aws-cli",
        
        "count": 2,
        "items": [
            
            {
    "kind": "page",
    "title": "Running aws-vault in macOS with local Docker containers",
    "description": "",
    "summary": {
        "content": "Overview aws-vault is a tool for storing your AWS credentials in your system keychain instead of as a plain text file on-disk. Credentials and other secrets (including your various system passwords) are stored inside your system keychain. They are encrypted, and cannot easily be stolen by a rogue script or application. By keeping your AWS credentials in your system keychain, they are available to you when you are logged in, unavailable when you are logged out, and provide an important layer of security that the standard plain text storage method does not.",
        "isTruncated": true
    },
    "published": "2019-04-19T01:32:30Z",
    "updated": "2019-12-26T16:46:47-08:00",
    "permalink": "https://ryanparman.com/posts/2019/running-aws-vault-with-local-docker-containers/",
    "relativePermalink": "/posts/2019/running-aws-vault-with-local-docker-containers/",
    "aliases": ["/2019/04/19/running-aws-vault-with-local-docker-containers"],
    "images": ["https://cdn.ryanparman.com/hugo/posts/2019/secure-auth@2x.jpg", "https://cdn.ryanparman.com/hugo/posts/2019/keychain@2x.jpg", "https://cdn.ryanparman.com/hugo/posts/2019/generate-tokens@2x.png", "https://cdn.ryanparman.com/hugo/posts/2018/docker-logo.jpg"],
    "videos": [],
    "categories": ["Software"],
    "tags": ["99designs", "aws", "aws-cli", "aws-vault", "bash", "docker", "ec2", "elastic-beanstalk", "golang", "keychain", "mac", "macos", "parameter-store", "secrets", "session-tokens", "site-reliability-engineering", "sre"],
    "series": [],
    "keywords": [],
    "meta": {
        "wordCount": 896,
        "readingTime": "5 minutes",
        "language": "en",
        "isDraft": false,
        "isHome": false,
        "isNode": false,
        "isPage": true,
        "isTranslated": false
    },
    "sourceFile": {
        "path": "posts/2019/20190419-running-aws-vault-with-local-docker-containers.md",
        "logicalName": "20190419-running-aws-vault-with-local-docker-containers.md",
        "translationBaseName": "20190419-running-aws-vault-with-local-docker-containers",
        "baseFileName": "20190419-running-aws-vault-with-local-docker-containers",
        "ext": "md",
        "lang": "en",
        "dir": "posts/2019/"
    },
    "content": {
        "tableOfContents": "\u003cnav id=\"TableOfContents\"\u003e\n  \u003cul\u003e\n    \u003cli\u003e\u003ca href=\"#overview\"\u003eOverview\u003c/a\u003e\u003c/li\u003e\n    \u003cli\u003e\u003ca href=\"#leveraging-the-keychain\"\u003eLeveraging the Keychain\u003c/a\u003e\u003c/li\u003e\n    \u003cli\u003e\u003ca href=\"#aws-config-file\"\u003eAWS Config File\u003c/a\u003e\u003c/li\u003e\n    \u003cli\u003e\u003ca href=\"#viewing-credentials\"\u003eViewing Credentials\u003c/a\u003e\u003c/li\u003e\n    \u003cli\u003e\u003ca href=\"#token-types\"\u003eToken Types\u003c/a\u003e\u003c/li\u003e\n    \u003cli\u003e\u003ca href=\"#passing-to-local-docker\"\u003ePassing to (local) Docker\u003c/a\u003e\u003c/li\u003e\n    \u003cli\u003e\u003ca href=\"#conclusion\"\u003eConclusion\u003c/a\u003e\u003c/li\u003e\n  \u003c/ul\u003e\n\u003c/nav\u003e",
        "html":"\u003cdiv class=\"pa2-ns\"\u003e\n\t\u003camp-img src=\"https://cdn.ryanparman.com/hugo/posts/2019/secure-auth@2x.jpg\" layout=\"responsive\" width=\"2000\" height=\"873\"\u003e\u003c/amp-img\u003e\n    \u003cp class=\"f6 gray tc db\"\u003e\u003c/p\u003e\n\u003c/div\u003e\n\n\u003ch2 id=\"overview\"\u003eOverview\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003e\u003ca href=\"https://github.com/99designs/aws-vault\"\u003eaws-vault\u003c/a\u003e\u003c/strong\u003e is a tool for storing your AWS credentials in your system keychain instead of as a plain text file on-disk.\u003c/p\u003e\n\u003cp\u003eCredentials and other secrets (including your various system passwords) are stored inside your system keychain. They are encrypted, and cannot easily be stolen by a rogue script or application. By keeping your AWS credentials in your system keychain, they are available to you when you are logged in, unavailable when you are logged out, and provide an important layer of security that the standard plain text storage method does not.\u003c/p\u003e\n\u003cp\u003eIt is designed to work cooperatively with the \u003ca href=\"https://aws.amazon.com/cli/\"\u003eAWS Unified CLI Tools\u003c/a\u003e. It also provides utilities for other AWS best practices such as being able to generate session tokens, or logging into the AWS Console with your IAM credentials using a simple command.\u003c/p\u003e\n\u003cp\u003eYou can learn more about the thinking behind it from the \u003ca href=\"https://99designs.com.au/tech-blog/blog/2015/10/26/aws-vault/\"\u003eoriginal 99 designs blog post\u003c/a\u003e.\u003c/p\u003e\n\u003ch2 id=\"leveraging-the-keychain\"\u003eLeveraging the Keychain\u003c/h2\u003e\n\u003cp\u003eBy default, every Mac user has a \u003cem\u003esystem\u003c/em\u003e and a \u003cem\u003elogin\u003c/em\u003e keychain that stores the bulk of your secure information (e.g., certificate authorities which enable SSL/TLS connections, website passwords or credit cards saved in your browser).\u003c/p\u003e\n\u003cdiv class=\"pa2-ns\"\u003e\n\t\u003camp-img src=\"https://cdn.ryanparman.com/hugo/posts/2019/keychain@2x.jpg\" layout=\"responsive\" width=\"1920\" height=\"1080\"\u003e\u003c/amp-img\u003e\n    \u003cp class=\"f6 gray tc db\"\u003e\u003c/p\u003e\n\u003c/div\u003e\n\n\u003cp\u003eOn macOS, credentials are stored in a non-\u003cem\u003elogin\u003c/em\u003e keychain in \u003cem\u003eKeychain Access.app\u003c/em\u003e. Instead, they are stored in a new \u003cem\u003eaws-vault\u003c/em\u003e keychain. In order to manage these credentials with the \u003cem\u003eKeychain Access.app\u003c/em\u003e app, you\u0026rsquo;ll need to import it.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cem\u003eFile → Import Items…\u003c/em\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eChoose \u003ccode\u003eaws-vault.keychain-db\u003c/code\u003e from the default directory.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eRight click → \u003cem\u003eChange Settings for Keychain “aws-vault”…\u003c/em\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eChange the value for \u003cem\u003eLock after {NUMBER} minutes of inactivity\u003c/em\u003e to something like 1440 minutes (1 day). Feel free to tune for security/convenience according to your tastes.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"aws-config-file\"\u003eAWS Config File\u003c/h2\u003e\n\u003cp\u003eAfter adding credentials to \u003ccode\u003eaws-vault\u003c/code\u003e (e.g., \u003ccode\u003eaws-vault add default\u003c/code\u003e), you can instruct the \u003ca href=\"https://aws.amazon.com/cli/\"\u003eaws-cli\u003c/a\u003e to use \u003ccode\u003eaws-vault\u003c/code\u003e instead of \u003ccode\u003e~/.aws/credentials\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eHere is an \u003ccode\u003e~/.aws/config\u003c/code\u003e entry for the \u003cem\u003edefault\u003c/em\u003e profile:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4\"\u003e\u003ccode class=\"language-ini\" data-lang=\"ini\"\u003e\u003cspan style=\"color:#66d9ef\"\u003e[default]\u003c/span\u003e\n\u003cspan style=\"color:#a6e22e\"\u003eregion\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003eus-east-1\u003c/span\u003e\n\u003cspan style=\"color:#a6e22e\"\u003ecredential_process\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003eaws-vault exec -j default\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eAfter all credentials are stored in \u003ccode\u003eaws-vault\u003c/code\u003e, and all \u003ccode\u003e~/.aws/config\u003c/code\u003e entries have been updated with the \u003ccode\u003ecredential_process\u003c/code\u003e line, \u003ccode\u003e~/.aws/credentials\u003c/code\u003e should be \u003cstrong\u003eempty\u003c/strong\u003e.\u003c/p\u003e\n\u003ch2 id=\"viewing-credentials\"\u003eViewing Credentials\u003c/h2\u003e\n\u003caside class=\"age aside container flex\"\u003e\n  \u003cp\u003emacOS ships with the FreeBSD flavor of command line tools instead of the GNU flavor which ships with most Linuxes. This post references the GNU flavor. Please see “\u003ca href=\"/posts/2019/using-gnu-command-line-tools-in-macos-instead-of-freebsd-tools/\"\u003eUsing GNU command line tools in macOS instead of FreeBSD tools\u003c/a\u003e” for more information.\u003c/p\u003e\n\u003c/aside\u003e\n\n\u003cp\u003eIf you want to view the credentials for a profile, or if you want to expose them as environment variables, you can run:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003eaws-vault exec default -- env | grep --no-color ^AWS | sort\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eIf you want to \u003cem\u003euse\u003c/em\u003e them, the \u003ca href=\"https://aws.amazon.com/cli/\"\u003eaws-cli\u003c/a\u003e will \u003ca href=\"https://docs.aws.amazon.com/cli/latest/topic/config-vars.html#id1\"\u003epick up environment variables before it looks for a credentials definition\u003c/a\u003e. So, if you want to use \u003ca href=\"https://github.com/99designs/aws-vault\"\u003eaws-vault\u003c/a\u003e with \u003ca href=\"https://aws.amazon.com/cli/\"\u003eaws-cli\u003c/a\u003e without specifying the \u003ccode\u003ecredential_process\u003c/code\u003e setting in your \u003ccode\u003e~/.aws/config\u003c/code\u003e entry, you can do something like this:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003eaws-vault exec default -- aws s3 ls\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"token-types\"\u003eToken Types\u003c/h2\u003e\n\u003cp\u003eThe AWS CLI (and any other tools built on AWS SDKs) will leverage the \u003ccode\u003eAWS_SESSION_TOKEN\u003c/code\u003e and \u003ccode\u003eAWS_SECURITY_TOKEN\u003c/code\u003e values before leveraging the \u003ccode\u003eAWS_ACCESS_KEY_ID\u003c/code\u003e and \u003ccode\u003eAWS_SECRET_ACCESS_KEY\u003c/code\u003e values.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eAWS_SESSION_TOKEN\u003c/code\u003e and \u003ccode\u003eAWS_SECURITY_TOKEN\u003c/code\u003e tokens are more secure because they are ephemeral, and expire after a short (measured in hours) TTL. For this reason, these should generally be used instead of the \u003ccode\u003eAWS_ACCESS_KEY_ID\u003c/code\u003e and \u003ccode\u003eAWS_SECRET_ACCESS_KEY\u003c/code\u003e values.\u003c/p\u003e\n\u003cdiv class=\"pa2-ns\"\u003e\n\t\u003camp-img src=\"https://cdn.ryanparman.com/hugo/posts/2019/generate-tokens@2x.png\" layout=\"responsive\" width=\"2000\" height=\"874\"\u003e\u003c/amp-img\u003e\n    \u003cp class=\"f6 gray tc db\"\u003e\u003c/p\u003e\n\u003c/div\u003e\n\n\u003cp\u003e\u003cstrong\u003eBut there is an exception\u003c/strong\u003e — there are certain types of IAM-related tasks which cannot be performed using \u003ccode\u003eAWS_SESSION_TOKEN\u003c/code\u003e and \u003ccode\u003eAWS_SECURITY_TOKEN\u003c/code\u003e tokens, because they are IAM tokens themselves. In these cases, you want to fall back to the long-lived \u003ccode\u003eAWS_ACCESS_KEY_ID\u003c/code\u003e and \u003ccode\u003eAWS_SECRET_ACCESS_KEY\u003c/code\u003e values. You can do this by passing the \u003ccode\u003e--no-session\u003c/code\u003e option to the \u003ccode\u003eaws-vault\u003c/code\u003e command.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003eaws-vault exec default --no-session -- env | grep --no-color ^AWS | sort\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eHere, you can see that the \u003ccode\u003eAWS_SESSION_TOKEN\u003c/code\u003e and \u003ccode\u003eAWS_SECURITY_TOKEN\u003c/code\u003e tokens are not generated, so the AWS CLI (and any other tools built on AWS SDKs) will leverage the \u003ccode\u003eAWS_ACCESS_KEY_ID\u003c/code\u003e and \u003ccode\u003eAWS_SECRET_ACCESS_KEY\u003c/code\u003e values instead.\u003c/p\u003e\n\u003ch2 id=\"passing-to-local-docker\"\u003ePassing to (local) Docker\u003c/h2\u003e\n\u003cp\u003eIt is becoming more popular to provide Docker containers for running software, especially when that software has a number of (potentially-complex) dependencies. By wrapping everything up into a nice little Docker image, it makes it much simpler to build and distribute software that is meant to run locally.\u003c/p\u003e\n\u003cdiv class=\"pa2-ns\"\u003e\n\t\u003camp-img src=\"https://cdn.ryanparman.com/hugo/posts/2018/docker-logo.jpg\" layout=\"responsive\" width=\"2400\" height=\"1048\"\u003e\u003c/amp-img\u003e\n    \u003cp class=\"f6 gray tc db\"\u003e\u003c/p\u003e\n\u003c/div\u003e\n\n\u003cp\u003eWith the traditional \u003ccode\u003e~/.aws\u003c/code\u003e directory, you can mount it as read-only inside a Docker container if you want that Docker container to be able to communicate with AWS on your behalf.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003edocker run -ti -v $HOME/.aws:/root/.aws:ro \u003cspan style=\"color:#f92672\"\u003e{\u003c/span\u003eimage_name\u003cspan style=\"color:#f92672\"\u003e}\u003c/span\u003e sh\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eEasy, right? Wrap it in a \u003ccode\u003eMakefile\u003c/code\u003e or a Bash \u003ccode\u003ealias\u003c/code\u003e, and call it a day.\u003c/p\u003e\n\u003cp\u003eBut using \u003ccode\u003eaws-vault\u003c/code\u003e makes this a little more complicated. \u003ccode\u003eaws-vault\u003c/code\u003e runs on your local machine (not inside your Docker container), and your \u003ccode\u003e~/.aws/credentials\u003c/code\u003e file is empty. How do we pass your credentials into a Docker container?\u003c/p\u003e\n\u003cp\u003eBy exporting the environment variables and passing them to \u003ccode\u003edocker run\u003c/code\u003e.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003edocker run -ti \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e    --env-file \u0026lt;\u003cspan style=\"color:#f92672\"\u003e(\u003c/span\u003eaws-vault exec default -- env | grep --no-color ^AWS_\u003cspan style=\"color:#f92672\"\u003e)\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e    \u003cspan style=\"color:#f92672\"\u003e{\u003c/span\u003eimage_name\u003cspan style=\"color:#f92672\"\u003e}\u003c/span\u003e sh\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003caside class=\"age aside container flex\"\u003e\n\u003cp\u003eTested in \u003cb\u003eBash 3.2.57\u003c/b\u003e (latest GPLv2 release; ships by default in macOS) + \u003cb\u003eBash 5.0.3\u003c/b\u003e (GPLv3; installed via Homebrew).\u003c/p\u003e\n\u003c/aside\u003e\n\n\u003cp\u003eWow! What does this do?\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003eExports the credentials to the environment.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eFilters the environment variables by those that begin with \u003ccode\u003eAWS\u003c/code\u003e.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eRun Docker, passing the \u003ccode\u003eAWS_*\u003c/code\u003e environment variables into Docker.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eThis particular command will start an interactive \u003ccode\u003esh\u003c/code\u003e shell session. You can run other commands using \u003ca href=\"https://docs.docker.com/engine/reference/commandline/run/\"\u003e\u003ccode\u003edocker run\u003c/code\u003e\u003c/a\u003e as appropriate.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"conclusion\"\u003eConclusion\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/99designs/aws-vault\"\u003eaws-vault\u003c/a\u003e is a great tool for managing your credentials, helping you work with AWS-related tooling, and makes it easy to follow best-practices. If you\u0026rsquo;re interested in learning more, check out the \u003ccode\u003eREADME\u003c/code\u003e.\u003c/p\u003e\n",
        "plain":"  Overview aws-vault is a tool for storing your AWS credentials in your system keychain instead of as a plain text file on-disk.\nCredentials and other secrets (including your various system passwords) are stored inside your system keychain. They are encrypted, and cannot easily be stolen by a rogue script or application. By keeping your AWS credentials in your system keychain, they are available to you when you are logged in, unavailable when you are logged out, and provide an important layer of security that the standard plain text storage method does not.\nIt is designed to work cooperatively with the AWS Unified CLI Tools. It also provides utilities for other AWS best practices such as being able to generate session tokens, or logging into the AWS Console with your IAM credentials using a simple command.\nYou can learn more about the thinking behind it from the original 99 designs blog post.\nLeveraging the Keychain By default, every Mac user has a system and a login keychain that stores the bulk of your secure information (e.g., certificate authorities which enable SSL/TLS connections, website passwords or credit cards saved in your browser).\n  On macOS, credentials are stored in a non-login keychain in Keychain Access.app. Instead, they are stored in a new aws-vault keychain. In order to manage these credentials with the Keychain Access.app app, you\u0026rsquo;ll need to import it.\n  File → Import Items…\n  Choose aws-vault.keychain-db from the default directory.\n  Right click → Change Settings for Keychain “aws-vault”…\n  Change the value for Lock after {NUMBER} minutes of inactivity to something like 1440 minutes (1 day). Feel free to tune for security/convenience according to your tastes.\n  AWS Config File After adding credentials to aws-vault (e.g., aws-vault add default), you can instruct the aws-cli to use aws-vault instead of ~/.aws/credentials.\nHere is an ~/.aws/config entry for the default profile:\n[default] region=us-east-1 credential_process=aws-vault exec -j default After all credentials are stored in aws-vault, and all ~/.aws/config entries have been updated with the credential_process line, ~/.aws/credentials should be empty.\nViewing Credentials macOS ships with the FreeBSD flavor of command line tools instead of the GNU flavor which ships with most Linuxes. This post references the GNU flavor. Please see “Using GNU command line tools in macOS instead of FreeBSD tools” for more information.\n If you want to view the credentials for a profile, or if you want to expose them as environment variables, you can run:\naws-vault exec default -- env | grep --no-color ^AWS | sort If you want to use them, the aws-cli will pick up environment variables before it looks for a credentials definition. So, if you want to use aws-vault with aws-cli without specifying the credential_process setting in your ~/.aws/config entry, you can do something like this:\naws-vault exec default -- aws s3 ls Token Types The AWS CLI (and any other tools built on AWS SDKs) will leverage the AWS_SESSION_TOKEN and AWS_SECURITY_TOKEN values before leveraging the AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY values.\nAWS_SESSION_TOKEN and AWS_SECURITY_TOKEN tokens are more secure because they are ephemeral, and expire after a short (measured in hours) TTL. For this reason, these should generally be used instead of the AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY values.\n  But there is an exception — there are certain types of IAM-related tasks which cannot be performed using AWS_SESSION_TOKEN and AWS_SECURITY_TOKEN tokens, because they are IAM tokens themselves. In these cases, you want to fall back to the long-lived AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY values. You can do this by passing the --no-session option to the aws-vault command.\naws-vault exec default --no-session -- env | grep --no-color ^AWS | sort Here, you can see that the AWS_SESSION_TOKEN and AWS_SECURITY_TOKEN tokens are not generated, so the AWS CLI (and any other tools built on AWS SDKs) will leverage the AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY values instead.\nPassing to (local) Docker It is becoming more popular to provide Docker containers for running software, especially when that software has a number of (potentially-complex) dependencies. By wrapping everything up into a nice little Docker image, it makes it much simpler to build and distribute software that is meant to run locally.\n  With the traditional ~/.aws directory, you can mount it as read-only inside a Docker container if you want that Docker container to be able to communicate with AWS on your behalf.\ndocker run -ti -v $HOME/.aws:/root/.aws:ro {image_name} sh Easy, right? Wrap it in a Makefile or a Bash alias, and call it a day.\nBut using aws-vault makes this a little more complicated. aws-vault runs on your local machine (not inside your Docker container), and your ~/.aws/credentials file is empty. How do we pass your credentials into a Docker container?\nBy exporting the environment variables and passing them to docker run.\ndocker run -ti \\  --env-file \u0026lt;(aws-vault exec default -- env | grep --no-color ^AWS_) \\  {image_name} sh  Tested in Bash 3.2.57 (latest GPLv2 release; ships by default in macOS) + Bash 5.0.3 (GPLv3; installed via Homebrew).\n Wow! What does this do?\n  Exports the credentials to the environment.\n  Filters the environment variables by those that begin with AWS.\n  Run Docker, passing the AWS_* environment variables into Docker.\n  This particular command will start an interactive sh shell session. You can run other commands using docker run as appropriate.\n  Conclusion aws-vault is a great tool for managing your credentials, helping you work with AWS-related tooling, and makes it easy to follow best-practices. If you\u0026rsquo;re interested in learning more, check out the README.\n",
        "source":"\n{{\u003cfullimage src=\"https://cdn.ryanparman.com/hugo/posts/2019/secure-auth@2x.jpg\" alt=\"Using aws-vault\" width=\"2000\" height=\"873\" \u003e}}\n\n## Overview\n\n**[aws-vault]** is a tool for storing your AWS credentials in your system keychain instead of as a plain text file on-disk.\n\nCredentials and other secrets (including your various system passwords) are stored inside your system keychain. They are encrypted, and cannot easily be stolen by a rogue script or application. By keeping your AWS credentials in your system keychain, they are available to you when you are logged in, unavailable when you are logged out, and provide an important layer of security that the standard plain text storage method does not.\n\nIt is designed to work cooperatively with the [AWS Unified CLI Tools][aws-cli]. It also provides utilities for other AWS best practices such as being able to generate session tokens, or logging into the AWS Console with your IAM credentials using a simple command.\n\nYou can learn more about the thinking behind it from the [original 99 designs blog post]({{\u003c wayback \"https://99designs.com.au/tech-blog/blog/2015/10/26/aws-vault/\" \u003e}}).\n\n## Leveraging the Keychain\n\nBy default, every Mac user has a _system_ and a _login_ keychain that stores the bulk of your secure information (e.g., certificate authorities which enable SSL/TLS connections, website passwords or credit cards saved in your browser).\n\n{{\u003cfullimage src=\"https://cdn.ryanparman.com/hugo/posts/2019/keychain@2x.jpg\" alt=\"Leveraging the Keychain\" width=\"1920\" height=\"1080\" \u003e}}\n\nOn macOS, credentials are stored in a non-_login_ keychain in _Keychain Access.app_. Instead, they are stored in a new _aws-vault_ keychain. In order to manage these credentials with the _Keychain Access.app_ app, you'll need to import it.\n\n1. _File → Import Items…_\n\n1. Choose `aws-vault.keychain-db` from the default directory.\n\n1. Right click → _Change Settings for Keychain “aws-vault”…_\n\n1. Change the value for _Lock after {NUMBER} minutes of inactivity_ to something like 1440 minutes (1 day). Feel free to tune for security/convenience according to your tastes.\n\n## AWS Config File\n\nAfter adding credentials to `aws-vault` (e.g., `aws-vault add default`), you can instruct the [aws-cli] to use `aws-vault` instead of `~/.aws/credentials`.\n\nHere is an `~/.aws/config` entry for the _default_ profile:\n\n```ini\n[default]\nregion=us-east-1\ncredential_process=aws-vault exec -j default\n```\n\nAfter all credentials are stored in `aws-vault`, and all `~/.aws/config` entries have been updated with the `credential_process` line, `~/.aws/credentials` should be **empty**.\n\n## Viewing Credentials\n\n{{\u003cmac-gnu\u003e}}\n\nIf you want to view the credentials for a profile, or if you want to expose them as environment variables, you can run:\n\n```bash\naws-vault exec default -- env | grep --no-color ^AWS | sort\n```\n\nIf you want to _use_ them, the [aws-cli] will [pick up environment variables before it looks for a credentials definition](https://docs.aws.amazon.com/cli/latest/topic/config-vars.html#id1). So, if you want to use [aws-vault] with [aws-cli] without specifying the `credential_process` setting in your `~/.aws/config` entry, you can do something like this:\n\n```bash\naws-vault exec default -- aws s3 ls\n```\n\n## Token Types\n\nThe AWS CLI (and any other tools built on AWS SDKs) will leverage the `AWS_SESSION_TOKEN` and `AWS_SECURITY_TOKEN` values before leveraging the `AWS_ACCESS_KEY_ID` and `AWS_SECRET_ACCESS_KEY` values.\n\n`AWS_SESSION_TOKEN` and `AWS_SECURITY_TOKEN` tokens are more secure because they are ephemeral, and expire after a short (measured in hours) TTL. For this reason, these should generally be used instead of the `AWS_ACCESS_KEY_ID` and `AWS_SECRET_ACCESS_KEY` values.\n\n{{\u003cfullimage src=\"https://cdn.ryanparman.com/hugo/posts/2019/generate-tokens@2x.png\" alt=\"Generating Secure Tokens\" width=\"2000\" height=\"874\" \u003e}}\n\n**But there is an exception** — there are certain types of IAM-related tasks which cannot be performed using `AWS_SESSION_TOKEN` and `AWS_SECURITY_TOKEN` tokens, because they are IAM tokens themselves. In these cases, you want to fall back to the long-lived `AWS_ACCESS_KEY_ID` and `AWS_SECRET_ACCESS_KEY` values. You can do this by passing the `--no-session` option to the `aws-vault` command.\n\n```bash\naws-vault exec default --no-session -- env | grep --no-color ^AWS | sort\n```\n\nHere, you can see that the `AWS_SESSION_TOKEN` and `AWS_SECURITY_TOKEN` tokens are not generated, so the AWS CLI (and any other tools built on AWS SDKs) will leverage the `AWS_ACCESS_KEY_ID` and `AWS_SECRET_ACCESS_KEY` values instead.\n\n## Passing to (local) Docker\n\nIt is becoming more popular to provide Docker containers for running software, especially when that software has a number of (potentially-complex) dependencies. By wrapping everything up into a nice little Docker image, it makes it much simpler to build and distribute software that is meant to run locally.\n\n{{\u003cfullimage src=\"https://cdn.ryanparman.com/hugo/posts/2018/docker-logo.jpg\" alt=\"Docker Logo\" width=\"2400\" height=\"1048\" \u003e}}\n\nWith the traditional `~/.aws` directory, you can mount it as read-only inside a Docker container if you want that Docker container to be able to communicate with AWS on your behalf.\n\n```bash\ndocker run -ti -v $HOME/.aws:/root/.aws:ro {image_name} sh\n```\n\nEasy, right? Wrap it in a `Makefile` or a Bash `alias`, and call it a day.\n\nBut using `aws-vault` makes this a little more complicated. `aws-vault` runs on your local machine (not inside your Docker container), and your `~/.aws/credentials` file is empty. How do we pass your credentials into a Docker container?\n\nBy exporting the environment variables and passing them to `docker run`.\n\n```bash\ndocker run -ti \\\n    --env-file \u003c(aws-vault exec default -- env | grep --no-color ^AWS_) \\\n    {image_name} sh\n```\n\n{{\u003caside\u003e}}\n\u003cp\u003eTested in \u003cb\u003eBash 3.2.57\u003c/b\u003e (latest GPLv2 release; ships by default in macOS) + \u003cb\u003eBash 5.0.3\u003c/b\u003e (GPLv3; installed via Homebrew).\u003c/p\u003e\n{{\u003c/aside\u003e}}\n\nWow! What does this do?\n\n1. Exports the credentials to the environment.\n\n1. Filters the environment variables by those that begin with `AWS`.\n\n1. Run Docker, passing the `AWS_*` environment variables into Docker.\n\n1. This particular command will start an interactive `sh` shell session. You can run other commands using [`docker run`](https://docs.docker.com/engine/reference/commandline/run/) as appropriate.\n\n## Conclusion\n\n[aws-vault] is a great tool for managing your credentials, helping you work with AWS-related tooling, and makes it easy to follow best-practices. If you're interested in learning more, check out the `README`.\n\n  [aws-cli]: https://aws.amazon.com/cli/\n  [aws-vault]: https://github.com/99designs/aws-vault\n"},
    "links": {
        "prev": {"title": "Converting iMessage Stickers, Animoji, and Memoji to Slackmoji (Slack Emoji)", "permalink": "https://ryanparman.com/posts/2019/converting-imessage-stickers-animoji-and-memoji-to-slackmoji-slack-emoji/"},
        "next": {"title": "Using GNU command line tools in macOS instead of FreeBSD tools", "permalink": "https://ryanparman.com/posts/2019/using-gnu-command-line-tools-in-macos-instead-of-freebsd-tools/"},
        "ignore": "me"
    }
}

            
            , {
    "kind": "page",
    "title": "Easily SSH into Amazon EC2 instances using the Name tag",
    "description": "",
    "summary": {
        "content": "It’s been a while since I’ve written about code, so I thought I’d post this little AWS-related tip for OS X and Linux users. If you have the Unified AWS CLI Tools configured, you can add these functions to your Bash profile (typically either ~/.bash_profile or ~/.profile) to enable you to SSH into an instance by “Name” tag, or simply lookup the IP address or DNS hostname. hostname_from_instance \u0026lt;instance-name\u0026gt; ip_from_instance \u0026lt;instance-name\u0026gt; ssh-aws \u0026lt;instance-name\u0026gt; Bash code function hostname_from_instance() { echo $(aws ec2 describe-instances --filters \u0026#34;{\\\u0026#34;Name\\\u0026#34;:\\\u0026#34;tag:Name\\\u0026#34;, \\\u0026#34;Values\\\u0026#34;:[\\\u0026#34;$1\\\u0026#34;]}\u0026#34; --query=\u0026#39;Reservations[0].",
        "isTruncated": true
    },
    "published": "2014-01-29T10:42:14Z",
    "updated": "2019-02-10T21:35:12-08:00",
    "permalink": "https://ryanparman.com/posts/2014/easily-ssh-into-amazon-ec2-instances-using-the-name-tag/",
    "relativePermalink": "/posts/2014/easily-ssh-into-amazon-ec2-instances-using-the-name-tag/",
    "aliases": ["/2014/01/29/easily-ssh-into-amazon-ec2-instances-using-the-name-tag/"],
    "images": [],
    "videos": [],
    "categories": ["Projects and Code"],
    "tags": ["aws", "ec2", "ssh", "aws-cli", "jmespath"],
    "series": [],
    "keywords": [],
    "meta": {
        "wordCount": 268,
        "readingTime": "2 minutes",
        "language": "en",
        "isDraft": false,
        "isHome": false,
        "isNode": false,
        "isPage": true,
        "isTranslated": false
    },
    "sourceFile": {
        "path": "posts/2014/20140129-easily-ssh-into-amazon-ec2-instances-using-the-name-tag.md",
        "logicalName": "20140129-easily-ssh-into-amazon-ec2-instances-using-the-name-tag.md",
        "translationBaseName": "20140129-easily-ssh-into-amazon-ec2-instances-using-the-name-tag",
        "baseFileName": "20140129-easily-ssh-into-amazon-ec2-instances-using-the-name-tag",
        "ext": "md",
        "lang": "en",
        "dir": "posts/2014/"
    },
    "content": {
        "tableOfContents": "\u003cnav id=\"TableOfContents\"\u003e\n  \u003cul\u003e\n    \u003cli\u003e\u003ca href=\"#bash-code\"\u003eBash code\u003c/a\u003e\u003c/li\u003e\n    \u003cli\u003e\u003ca href=\"#notes\"\u003eNotes\u003c/a\u003e\u003c/li\u003e\n    \u003cli\u003e\u003ca href=\"#references\"\u003eReferences\u003c/a\u003e\u003c/li\u003e\n  \u003c/ul\u003e\n\u003c/nav\u003e",
        "html":"\u003cp\u003eIt’s been a while since I’ve written about code, so I thought I’d post this little AWS-related tip for OS X and Linux users.\u003c/p\u003e\n\u003cp\u003eIf you have the \u003ca href=\"https://web.archive.org/web/20140129104214/https://github.com/aws/aws-cli/\"\u003eUnified AWS CLI Tools\u003c/a\u003e configured, you can add these functions to your Bash profile (typically either \u003ccode\u003e~/.bash_profile\u003c/code\u003e or \u003ccode\u003e~/.profile\u003c/code\u003e) to enable you to SSH into an instance by “Name” tag, or simply lookup the IP address or DNS hostname.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003ehostname_from_instance \u0026lt;instance-name\u0026gt;\n\nip_from_instance \u0026lt;instance-name\u0026gt;\n\nssh-aws \u0026lt;instance-name\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"bash-code\"\u003eBash code\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"color:#66d9ef\"\u003efunction\u003c/span\u003e hostname_from_instance\u003cspan style=\"color:#f92672\"\u003e()\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e{\u003c/span\u003e\n    echo \u003cspan style=\"color:#66d9ef\"\u003e$(\u003c/span\u003eaws ec2 describe-instances --filters \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;{\\\u0026#34;Name\\\u0026#34;:\\\u0026#34;tag:Name\\\u0026#34;, \\\u0026#34;Values\\\u0026#34;:[\\\u0026#34;\u003c/span\u003e$1\u003cspan style=\"color:#e6db74\"\u003e\\\u0026#34;]}\u0026#34;\u003c/span\u003e --query\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;Reservations[0].Instances[0].PublicDnsName\u0026#39;\u003c/span\u003e | tr -d \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;\u0026#34;\u0026#39;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003e)\u003c/span\u003e\n\u003cspan style=\"color:#f92672\"\u003e}\u003c/span\u003e\n\n\u003cspan style=\"color:#66d9ef\"\u003efunction\u003c/span\u003e ip_from_instance\u003cspan style=\"color:#f92672\"\u003e()\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e{\u003c/span\u003e\n    echo \u003cspan style=\"color:#66d9ef\"\u003e$(\u003c/span\u003eaws ec2 describe-instances --filters \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;{\\\u0026#34;Name\\\u0026#34;:\\\u0026#34;tag:Name\\\u0026#34;, \\\u0026#34;Values\\\u0026#34;:[\\\u0026#34;\u003c/span\u003e$1\u003cspan style=\"color:#e6db74\"\u003e\\\u0026#34;]}\u0026#34;\u003c/span\u003e --query\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;Reservations[0].Instances[0].PublicIpAddress\u0026#39;\u003c/span\u003e | tr -d \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;\u0026#34;\u0026#39;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003e)\u003c/span\u003e\n\u003cspan style=\"color:#f92672\"\u003e}\u003c/span\u003e\n\n\u003cspan style=\"color:#66d9ef\"\u003efunction\u003c/span\u003e ssh-aws\u003cspan style=\"color:#f92672\"\u003e()\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e{\u003c/span\u003e\n    ssh -i ~/.ssh/your-keypair.pem ec2-user@\u003cspan style=\"color:#66d9ef\"\u003e$(\u003c/span\u003eip_from_instance \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;\u003c/span\u003e$1\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003e)\u003c/span\u003e\n\u003cspan style=\"color:#f92672\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"notes\"\u003eNotes\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eThis assumes that every instance you have has a unique “Name” tag, and will return the IP address or public DNS hostname of that instance (for use with SSH access). If multiple instances share the same “Name” tag, it will simply use the first “Name” match.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eIf you’re running instances inside a (private) VPC, you should expect to lookup the public Elastic IP address for the instance.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eIf you’re running instances inside a (public, classic) EC2, you should expect to lookup the public DNS hostname (unless you’ve configured an Elastic IP — in which case, go nuts).\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eIn the case where you’re running instances in the private subnet of a VPC, and SSH access to those instances is only possible from a bastion host in the public subnet, this is not the solution for you.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eFeel free to tweak/adjust as necessary.\u003c/p\u003e\n\u003ch2 id=\"references\"\u003eReferences\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://web.archive.org/web/20140129104214/https://github.com/aws/aws-cli/\"\u003eUnified AWS CLI Tools\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://web.archive.org/web/20140129104214/https://github.com/boto/jmespath\"\u003eJMESpath\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://web.archive.org/web/20140129104214/http://docs.aws.amazon.com/AWSEC2/latest/APIReference/ApiReference-query-DescribeInstances.html\"\u003eEC2 API Reference: DescribeInstances\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n",
        "plain":"It’s been a while since I’ve written about code, so I thought I’d post this little AWS-related tip for OS X and Linux users.\nIf you have the Unified AWS CLI Tools configured, you can add these functions to your Bash profile (typically either ~/.bash_profile or ~/.profile) to enable you to SSH into an instance by “Name” tag, or simply lookup the IP address or DNS hostname.\nhostname_from_instance \u0026lt;instance-name\u0026gt; ip_from_instance \u0026lt;instance-name\u0026gt; ssh-aws \u0026lt;instance-name\u0026gt; Bash code function hostname_from_instance() { echo $(aws ec2 describe-instances --filters \u0026#34;{\\\u0026#34;Name\\\u0026#34;:\\\u0026#34;tag:Name\\\u0026#34;, \\\u0026#34;Values\\\u0026#34;:[\\\u0026#34;$1\\\u0026#34;]}\u0026#34; --query=\u0026#39;Reservations[0].Instances[0].PublicDnsName\u0026#39; | tr -d \u0026#39;\u0026#34;\u0026#39;) } function ip_from_instance() { echo $(aws ec2 describe-instances --filters \u0026#34;{\\\u0026#34;Name\\\u0026#34;:\\\u0026#34;tag:Name\\\u0026#34;, \\\u0026#34;Values\\\u0026#34;:[\\\u0026#34;$1\\\u0026#34;]}\u0026#34; --query=\u0026#39;Reservations[0].Instances[0].PublicIpAddress\u0026#39; | tr -d \u0026#39;\u0026#34;\u0026#39;) } function ssh-aws() { ssh -i ~/.ssh/your-keypair.pem ec2-user@$(ip_from_instance \u0026#34;$1\u0026#34;) } Notes   This assumes that every instance you have has a unique “Name” tag, and will return the IP address or public DNS hostname of that instance (for use with SSH access). If multiple instances share the same “Name” tag, it will simply use the first “Name” match.\n  If you’re running instances inside a (private) VPC, you should expect to lookup the public Elastic IP address for the instance.\n  If you’re running instances inside a (public, classic) EC2, you should expect to lookup the public DNS hostname (unless you’ve configured an Elastic IP — in which case, go nuts).\n  In the case where you’re running instances in the private subnet of a VPC, and SSH access to those instances is only possible from a bastion host in the public subnet, this is not the solution for you.\n  Feel free to tweak/adjust as necessary.\nReferences  Unified AWS CLI Tools JMESpath EC2 API Reference: DescribeInstances  ",
        "source":"\nIt’s been a while since I’ve written about code, so I thought I’d post this little AWS-related tip for OS X and Linux users.\n\nIf you have the [Unified AWS CLI Tools]({{% wayback \"https://github.com/aws/aws-cli/\" %}}) configured, you can add these functions to your Bash profile (typically either `~/.bash_profile` or `~/.profile`) to enable you to SSH into an instance by “Name” tag, or simply lookup the IP address or DNS hostname.\n\n```bash\nhostname_from_instance \u003cinstance-name\u003e\n\nip_from_instance \u003cinstance-name\u003e\n\nssh-aws \u003cinstance-name\u003e\n```\n\n## Bash code\n\n```bash\nfunction hostname_from_instance() {\n    echo $(aws ec2 describe-instances --filters \"{\\\"Name\\\":\\\"tag:Name\\\", \\\"Values\\\":[\\\"$1\\\"]}\" --query='Reservations[0].Instances[0].PublicDnsName' | tr -d '\"')\n}\n\nfunction ip_from_instance() {\n    echo $(aws ec2 describe-instances --filters \"{\\\"Name\\\":\\\"tag:Name\\\", \\\"Values\\\":[\\\"$1\\\"]}\" --query='Reservations[0].Instances[0].PublicIpAddress' | tr -d '\"')\n}\n\nfunction ssh-aws() {\n    ssh -i ~/.ssh/your-keypair.pem ec2-user@$(ip_from_instance \"$1\")\n}\n```\n\n## Notes\n\n* This assumes that every instance you have has a unique “Name” tag, and will return the IP address or public DNS hostname of that instance (for use with SSH access). If multiple instances share the same “Name” tag, it will simply use the first “Name” match.\n\n* If you’re running instances inside a (private) VPC, you should expect to lookup the public Elastic IP address for the instance.\n\n* If you’re running instances inside a (public, classic) EC2, you should expect to lookup the public DNS hostname (unless you’ve configured an Elastic IP — in which case, go nuts).\n\n* In the case where you’re running instances in the private subnet of a VPC, and SSH access to those instances is only possible from a bastion host in the public subnet, this is not the solution for you.\n\nFeel free to tweak/adjust as necessary.\n\n## References\n\n* [Unified AWS CLI Tools]({{% wayback \"https://github.com/aws/aws-cli/\" %}})\n* [JMESpath]({{% wayback \"https://github.com/boto/jmespath\" %}})\n* [EC2 API Reference: DescribeInstances]({{% wayback \"http://docs.aws.amazon.com/AWSEC2/latest/APIReference/ApiReference-query-DescribeInstances.html\" %}})\n"},
    "links": {
        "prev": {"title": "Games of the Year, 2013", "permalink": "https://ryanparman.com/posts/2014/games-of-the-year-2013/"},
        "next": {"title": "If your website supports passwords, please stop sucking at it", "permalink": "https://ryanparman.com/posts/2014/if-your-website-supports-passwords-please-stop-sucking-at-it/"},
        "ignore": "me"
    }
}

            
        ]
    }
}
