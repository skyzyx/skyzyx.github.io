{
    "data": {
        
        
        "taxonomy": "tag",
        "term": "s3",
        
        "count": 1,
        "items": [
            
            {
    "kind": "page",
    "title": "Serving Bandwidth-Friendly Video with HTTP Live Streaming (HLS)",
    "description": "",
    "summary": {
        "content": "While YouTube is free (as in money) to use, the cost is paid in terms of privacy and advertising analytics. So I've decided to investigate self-hosting my video content. The Cost of YouTube With YouTube, you sacrifice privacy in favor of cost. YouTube is the very best at what they do (serve video to all resolutions and bandwidths), and they are backed by Google who is the very best at what they do (collect data in order to facilitate selling a primed audience to advertisers).",
        "isTruncated": true
    },
    "published": "2018-09-09T03:18:33Z",
    "updated": "2019-02-10T21:35:12-08:00",
    "permalink": "https://ryanparman.com/posts/2018/serving-bandwidth-friendly-video-with-hls/",
    "relativePermalink": "/posts/2018/serving-bandwidth-friendly-video-with-hls/",
    "aliases": ["/2018/09/09/serving-bandwidth-friendly-video-with-hls"],
    "images": ["https://cdn.ryanparman.com/hugo/posts/2018/adaptive-bitrate-streaming.png", "https://cdn.ryanparman.com/hugo/posts/2018/youtube-2017.png"],
    "videos": ["https://cdn.ryanparman.com/hls/hallelujah.fmp4/progressive.mp4"],
    "categories": ["Projects and Code"],
    "tags": ["youtube", "h.264", "hls", "mpeg", "dash", "streaming", "s3", "cloudfront", "safari", "chrome", "firefox", "edge"],
    "series": [],
    "keywords": [],
    "meta": {
        "wordCount": 1611,
        "readingTime": "8 minutes",
        "language": "en",
        "isDraft": false,
        "isHome": false,
        "isNode": false,
        "isPage": true,
        "isTranslated": false
    },
    "sourceFile": {
        "path": "posts/2018/20180909-serving-bandwidth-friendly-video-with-hls.md",
        "logicalName": "20180909-serving-bandwidth-friendly-video-with-hls.md",
        "translationBaseName": "20180909-serving-bandwidth-friendly-video-with-hls",
        "baseFileName": "20180909-serving-bandwidth-friendly-video-with-hls",
        "ext": "md",
        "lang": "en",
        "dir": "posts/2018/"
    },
    "content": {
        "tableOfContents": "\u003cnav id=\"TableOfContents\"\u003e\n  \u003cul\u003e\n    \u003cli\u003e\u003ca href=\"#the-cost-of-youtube\"\u003eThe Cost of YouTube\u003c/a\u003e\u003c/li\u003e\n    \u003cli\u003e\u003ca href=\"#self-hosting-video-content\"\u003eSelf-Hosting Video Content\u003c/a\u003e\n      \u003cul\u003e\n        \u003cli\u003e\u003ca href=\"#adaptive-bitrate-streaming\"\u003eAdaptive Bitrate Streaming\u003c/a\u003e\u003c/li\u003e\n        \u003cli\u003e\u003ca href=\"#http-live-streaming-hls\"\u003eHTTP Live Streaming (HLS)\u003c/a\u003e\u003c/li\u003e\n      \u003c/ul\u003e\n    \u003c/li\u003e\n    \u003cli\u003e\u003ca href=\"#sample-video\"\u003eSample Video\u003c/a\u003e\u003c/li\u003e\n    \u003cli\u003e\u003ca href=\"#implementation\"\u003eImplementation\u003c/a\u003e\n      \u003cul\u003e\n        \u003cli\u003e\u003ca href=\"#encoding-and-deploying-video\"\u003eEncoding and Deploying Video\u003c/a\u003e\u003c/li\u003e\n        \u003cli\u003e\u003ca href=\"#the-client-side-code\"\u003eThe Client-Side Code\u003c/a\u003e\u003c/li\u003e\n        \u003cli\u003e\u003ca href=\"#enabling-chrome-firefox-and-edge-using-hlsjs\"\u003eEnabling Chrome, Firefox, and Edge using hls.js\u003c/a\u003e\u003c/li\u003e\n        \u003cli\u003e\u003ca href=\"#cors\"\u003eCORS\u003c/a\u003e\u003c/li\u003e\n      \u003c/ul\u003e\n    \u003c/li\u003e\n  \u003c/ul\u003e\n\u003c/nav\u003e",
        "html":"\u003cp itemprop=\"description\" class=\"f5 f4-m f3-l mt0 lh-copy p-summary entry-summary\"\u003e\nWhile YouTube is free (as in money) to use, the cost is paid in terms of privacy and advertising analytics. So I've decided to investigate self-hosting my video content.\n\u003c/p\u003e\n\n\u003ch2 id=\"the-cost-of-youtube\"\u003eThe Cost of YouTube\u003c/h2\u003e\n\u003cp\u003eWith YouTube, you sacrifice privacy in favor of cost. YouTube is the very best at what they do (serve video to all resolutions and bandwidths), and they are backed by Google who is the very best at what they do (collect data in order to facilitate selling a primed audience to advertisers).\u003c/p\u003e\n\u003cdiv class=\"pa2-ns\"\u003e\n\t\u003camp-img src=\"https://cdn.ryanparman.com/hugo/posts/2018/youtube-2017.png\" layout=\"responsive\" width=\"\" height=\"\"\u003e\u003c/amp-img\u003e\n    \u003cp class=\"f6 gray tc db\"\u003e\u003c/p\u003e\n\u003c/div\u003e\n\n\u003cp\u003eThere’s nothing inherently wrong with that. We live in a capitalistic society; there is money to be made; Google/YouTube is providing a service to advertisers; many consumers will (knowingly or unknowingly) give up their privacy in exchange for free-as-in-money services.\u003c/p\u003e\n\u003cp\u003eBut as I\u0026rsquo;ve gotten older and started to realize just \u003cem\u003ehow much\u003c/em\u003e data Google has on each and every one of us, I\u0026rsquo;ve started valuing my privacy a lot more. I\u0026rsquo;d like to provide an option for you to protect your privacy as well.\u003c/p\u003e\n\u003ch2 id=\"self-hosting-video-content\"\u003eSelf-Hosting Video Content\u003c/h2\u003e\n\u003cp\u003eEven with efficient video codecs, video can still cost a lot of money to serve.\u003c/p\u003e\n\u003cp\u003eMany websites provide \u003cem\u003ea video\u003c/em\u003e to their users, wherein this video is a single file, and the browser will begin loading and playing the video from start to finish. This means that even if the user only watches the first few seconds of a 5 minute video, it\u0026rsquo;s possible that the video is downloaded in its entirety — which is an unnecessary cost.\u003c/p\u003e\n\u003cp\u003eHowever, we can provide a \u003cem\u003ebetter user experience\u003c/em\u003e as well as \u003cem\u003ereduce hosting costs\u003c/em\u003e by leveraging the ability to serve bandwidth-adaptive chunks of video to players on-demand.\u003c/p\u003e\n\u003ch3 id=\"adaptive-bitrate-streaming\"\u003eAdaptive Bitrate Streaming\u003c/h3\u003e\n\u003cp\u003eThere are two major, semi-compatible approaches to \u003ca href=\"https://en.wikipedia.org/wiki/Adaptive_bitrate_streaming\"\u003eadaptive bitrate streaming\u003c/a\u003e over HTTP. One is called \u003ca href=\"https://en.wikipedia.org/wiki/HTTP_Live_Streaming\"\u003eHTTP Live Streaming\u003c/a\u003e (“HLS”), and the other is called \u003ca href=\"https://en.wikipedia.org/wiki/Dynamic_Adaptive_Streaming_over_HTTP\"\u003eDynamic Adaptive Streaming over HTTP\u003c/a\u003e (“MPEG-DASH”).\u003c/p\u003e\n\u003cdiv class=\"pa2-ns\"\u003e\n\t\u003camp-img src=\"https://cdn.ryanparman.com/hugo/posts/2018/adaptive-bitrate-streaming.png\" layout=\"responsive\" width=\"\" height=\"\"\u003e\u003c/amp-img\u003e\n    \u003cp class=\"f6 gray tc db\"\u003e\u003c/p\u003e\n\u003c/div\u003e\n\n\u003cp\u003eFrom \u003ca href=\"https://en.wikipedia.org/wiki/Adaptive_bitrate_streaming\"\u003eWikipedia\u003c/a\u003e:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eAdaptive bitrate streaming is a technique used in streaming multimedia over computer networks. While in the past most video or audio streaming technologies utilized streaming protocols such as RTP with RTSP, today\u0026rsquo;s adaptive streaming technologies are almost exclusively based on HTTP and designed to work efficiently over large distributed HTTP networks such as the Internet.\u003c/p\u003e\n\u003cp\u003eIt works by detecting a user\u0026rsquo;s bandwidth and CPU capacity in real time and adjusting the quality of the media stream accordingly. It requires the use of an encoder which can encode a single source media (video or audio) at multiple bit rates. The player client switches between streaming the different encodings depending on available resources. \u0026ldquo;The result: very little buffering, fast start time and a good experience for both high-end and low-end connections.\u0026rdquo; […]\u003c/p\u003e\n\u003cp\u003eHTTP-based adaptive bitrate streaming technologies yield additional benefits over traditional server-driven adaptive bitrate streaming. First, since the streaming technology is built on top of HTTP, contrary to RTP-based adaptive streaming, the packets have no difficulties traversing firewall and NAT devices. Second, since HTTP streaming is purely client-driven, all adaptation logic resides at the client. This reduces the requirement of persistent connections between server and client application. Furthermore, the server is not required to maintain session state information on each client, increasing scalability. Finally, existing HTTP delivery infrastructure, such as HTTP caches and servers can be seamlessly adopted.\u003c/p\u003e\n\u003cp\u003eA scalable CDN is used to deliver media streaming to an Internet audience. The CDN receives the stream from the source at its Origin server, then replicates it to many or all of its Edge cache servers. The end-user requests the stream and is redirected to the \u0026ldquo;closest\u0026rdquo; Edge server. […] The use of HTTP-based adaptive streaming allows the Edge server to run a simple HTTP server software, whose licence cost is cheap or free, reducing software licensing cost, compared to costly media server licences (e.g. Adobe Flash Media Streaming Server). The CDN cost for HTTP streaming media is then similar to HTTP web caching CDN cost.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eThis means that we can use off-the-shelf services like \u003ca href=\"https://aws.amazon.com/s3\"\u003eAmazon S3\u003c/a\u003e and \u003ca href=\"https://aws.amazon.com/cloudfront\"\u003eAmazon CloudFront\u003c/a\u003e to serve video, which are relatively inexpensive and have large user-bases who can answer questions when you run into issues.\u003c/p\u003e\n\u003ch3 id=\"http-live-streaming-hls\"\u003eHTTP Live Streaming (HLS)\u003c/h3\u003e\n\u003cp\u003eAfter doing some research, I came across a blog post that was particularly helpful — “\u003ca href=\"https://vincent.bernat.ch/en/blog/2018-self-hosted-videos\"\u003eSelf-hosted videos with HLS\u003c/a\u003e” by Vincent Bernat.\u003c/p\u003e\n\u003cp\u003eVincent writes:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eTo serve HLS videos, you need three kinds of files:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ethe media segments (encoded with different bitrates/resolutions),\u003c/li\u003e\n\u003cli\u003ea media playlist for each variant, listing the media segments, and\u003c/li\u003e\n\u003cli\u003ea master playlist, listing the media playlists.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eMedia segments can come in two formats:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eMPEG-2 Transport Streams (TS), or\u003c/li\u003e\n\u003cli\u003eFragmented MP4.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eFragmented MP4 media segments are supported since iOS 10. They are a bit more efficient and can be reused to serve the same content as MPEG-DASH (only the playlists are different). Also, they can be served from the same file with range requests. However, if you want to target older versions of iOS, you need to stick with MPEG-2 TS.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eAt the time of this writing, iOS 12 will be out in a week or two. A quick search tells me that \u003ca href=\"https://data.apteligent.com/ios/\"\u003eiOS 10 and newer make up 85% of all iOS users\u003c/a\u003e. This means that I can pretty safely use the \u003cem\u003eFragmented MP4\u003c/em\u003e method which, according to \u003ca href=\"https://bitmovin.com/hls-news-wwdc-2016/\"\u003ethese\u003c/a\u003e \u003ca href=\"http://www.streamingmedia.com/Articles/ReadArticle.aspx?ArticleID=111796\"\u003esources\u003c/a\u003e, is more compatible with MPEG-DASH for some cross-over implementations in the future.\u003c/p\u003e\n\u003ch2 id=\"sample-video\"\u003eSample Video\u003c/h2\u003e\n\u003cdiv style=\"position: relative; padding-bottom: 56.25%; overflow: hidden;\"\u003e\n    \u003cvideo poster=\"https://cdn.ryanparman.com/hls/hallelujah.fmp4/poster.jpg\" controls preload=\"none\" style=\"position: absolute; width: 100%; height: 100%;\"\u003e\n      \u003csource src=\"https://cdn.ryanparman.com/hls/hallelujah.fmp4/index.m3u8\" type=\"application/vnd.apple.mpegurl\"\u003e\n      \u003csource src=\"https://cdn.ryanparman.com/hls/hallelujah.fmp4/progressive.mp4\" type='video/mp4; codecs=\"avc1.4d401f, mp4a.40.2\"'\u003e\n    \u003c/video\u003e\n\u003c/div\u003e\u003cp class=\"tc black-60 db mb2\"\u003e\u003csmall\u003e\u003cb\u003eSource:\u003c/b\u003e \u003ca href=\"https://youtu.be/e1C9kpMV2e8\"\u003eHallelujah - Brooklyn Duo (Piano \u0026#43; Cello)\u003c/a\u003e\u003c/small\u003e\u003c/p\u003e\n\u003ch2 id=\"implementation\"\u003eImplementation\u003c/h2\u003e\n\u003ch3 id=\"encoding-and-deploying-video\"\u003eEncoding and Deploying Video\u003c/h3\u003e\n\u003cp\u003eVincent Bernat provides a tool on GitHub which greatly simplifies the process of creating the various video fragments called \u003ca href=\"https://github.com/vincentbernat/video2hls\"\u003evideo2hls\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eFor \u003ca href=\"https://github.com/skyzyx/blog/blob/master/Makefile\"\u003ethis website\u003c/a\u003e, I have put together a workflow for creating and serving HLS video content.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003eI use \u003cstrong\u003eH.264\u003c/strong\u003e video with \u003cstrong\u003eAAC\u003c/strong\u003e audio wrapped inside an \u003cstrong\u003eMP4\u003c/strong\u003e container, \u003cem\u003eexclusively\u003c/em\u003e. These are all defined as part of the MPEG-4 specification, and is the \u003ca href=\"https://caniuse.com/#search=H.264\"\u003ebest-supported grouping of codecs and containers across all browsers and devices\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eHardware-level decoders are commonplace inside computers, phones, tablets, and set-top boxes like Xbox, PlayStation, and Apple TV.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eI have a directory called \u003ccode\u003estreaming-video\u003c/code\u003e, which is separate from the images that I use and push to S3. Video files are large, and I don\u0026rsquo;t want to accidentally push partially-completed video data to my caching CDN before they\u0026rsquo;re ready.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eI have a command which takes any video file inside the \u003ccode\u003estreaming-video\u003c/code\u003e folder, with a filename ending in \u003ccode\u003e-source.mp4\u003c/code\u003e, and passes it through \u003ccode\u003evideo2hls\u003c/code\u003e, creating a folder called \u003ccode\u003e{video}.fmp4\u003c/code\u003e which contains all of the video and playlist files I need across a large variety of bandwidths and resolutions.\u003c/p\u003e\n\u003cp\u003eIt will only do the work to create the directory and all of the fragmented files if the directory doesn\u0026rsquo;t already exist.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003efind ./streaming-video -type f -name \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;*-source.mp4\u0026#34;\u003c/span\u003e | xargs -I \u003cspan style=\"color:#f92672\"\u003e{}\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e    bash -c \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;if [ ! -d \u0026#34;${1%-source.mp4}.fmp4\u0026#34; ]; then \\\n\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e        video2hls --debug --output \u0026#34;${1%-source.mp4}.fmp4\u0026#34; --hls-type fmp4 \u0026#34;$1\u0026#34;; \\\n\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e    fi;\u0026#39;\u003c/span\u003e _ \u003cspan style=\"color:#f92672\"\u003e{}\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e\\;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eI find all of the \u003ccode\u003e.m3u8\u003c/code\u003e playlist files and gzip them (since they\u0026rsquo;re just text). This is essentially an in-place rewrite of the files.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003efind ./streaming-video -type f -name \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;*.m3u8\u0026#34;\u003c/span\u003e | xargs -P \u003cspan style=\"color:#ae81ff\"\u003e8\u003c/span\u003e -I \u003cspan style=\"color:#f92672\"\u003e{}\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e    bash -c \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;! gunzip -t $1 2\u0026gt;/dev/null \u0026amp;\u0026amp; gzip -v $1 \u0026amp;\u0026amp; mv -v $1.gz $1;\u0026#39;\u003c/span\u003e _ \u003cspan style=\"color:#f92672\"\u003e{}\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e\\;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eLastly, I push all of the files up to the \u003ccode\u003ehls\u003c/code\u003e folder in my S3 bucket using the \u003ca href=\"https://github.com/aws/aws-cli\"\u003eAWS Unified CLI Tools\u003c/a\u003e, setting the correct \u003ccode\u003eContent-Type\u003c/code\u003e and \u003ccode\u003eContent-Encoding\u003c/code\u003e headers.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"color:#75715e\"\u003e# The .m3u8 playlists that we gzipped\u003c/span\u003e\naws s3 sync ./streaming-video s3://blog.ryanparman.com/hls \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e    --exclude \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;*.*\u0026#39;\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e    --include \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;*.m3u8\u0026#39;\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e    --acl\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003epublic-read \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e    --cache-control max-age\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e31536000,public \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e    --content-type \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;application/vnd.apple.mpegurl\u0026#39;\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e    --content-encoding \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;gzip\u0026#39;\u003c/span\u003e\n\n\u003cspan style=\"color:#75715e\"\u003e# The video \u0026#34;posters\u0026#34;\u003c/span\u003e\naws s3 sync ./streaming-video s3://blog.ryanparman.com/hls \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e    --exclude \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;*.*\u0026#39;\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e    --include \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;*.jpg\u0026#39;\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e    --acl\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003epublic-read \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e    --cache-control max-age\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e31536000,public \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e    --content-type \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;image/jpeg\u0026#39;\u003c/span\u003e\n\n\u003cspan style=\"color:#75715e\"\u003e# The fragmented MP4 files\u003c/span\u003e\naws s3 sync ./streaming-video s3://blog.ryanparman.com/hls \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e    --exclude \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;*.*\u0026#39;\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e    --include \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;*.mp4\u0026#39;\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e    --acl\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003epublic-read \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e    --cache-control max-age\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e31536000,public \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e    --content-type \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;video/mp4\u0026#39;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"the-client-side-code\"\u003eThe Client-Side Code\u003c/h3\u003e\n\u003cp\u003eAfter pushing the content to our CDN, we can use the standard HTML5 \u003ccode\u003e\u0026lt;video\u0026gt;\u003c/code\u003e tag to tell browsers how to load the requested assets.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4\"\u003e\u003ccode class=\"language-html\" data-lang=\"html\"\u003e\u0026lt;\u003cspan style=\"color:#f92672\"\u003evideo\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eposter\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;https://cdn.ryanparman.com/hls/hallelujah.fmp4/poster.jpg\u0026#34;\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003econtrols\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003epreload\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;none\u0026#34;\u003c/span\u003e\u0026gt;\n    \u0026lt;\u003cspan style=\"color:#f92672\"\u003esource\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003esrc\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;https://cdn.ryanparman.com/hls/hallelujah.fmp4/index.m3u8\u0026#34;\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003etype\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;application/vnd.apple.mpegurl\u0026#34;\u003c/span\u003e\u0026gt;\n    \u0026lt;\u003cspan style=\"color:#f92672\"\u003esource\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003esrc\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;https://cdn.ryanparman.com/hls/hallelujah.fmp4/progressive.mp4\u0026#34;\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003etype\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;video/mp4; codecs=\u0026#34;avc1.4d401f, mp4a.40.2\u0026#34;\u0026#39;\u003c/span\u003e\u0026gt;\n\u0026lt;/\u003cspan style=\"color:#f92672\"\u003evideo\u003c/span\u003e\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003col\u003e\n\u003cli\u003e\n\u003cp\u003eHere, we have a static \u003cem\u003eposter\u003c/em\u003e image that the \u003ccode\u003e\u0026lt;video\u0026gt;\u003c/code\u003e element loads by default.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eNext, we have an HLS-compatible playlist file (\u003ccode\u003e.m3u8\u003c/code\u003e), which ultimately points to the correct \u003ccode\u003e.mp4\u003c/code\u003e files.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eLastly, we have a standard \u003ccode\u003e.mp4\u003c/code\u003e fallback.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"enabling-chrome-firefox-and-edge-using-hlsjs\"\u003eEnabling Chrome, Firefox, and Edge using hls.js\u003c/h3\u003e\n\u003cp\u003eDailymotion has released a JavaScript library called \u003ca href=\"https://github.com/video-dev/hls.js\"\u003ehls.js\u003c/a\u003e which enables HLS playback on browsers like Chrome, Firefox, and Edge using Fragmented MP4 sources.\u003c/p\u003e\n\u003cp\u003eYou can load the script from the CDN:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4\"\u003e\u003ccode class=\"language-html\" data-lang=\"html\"\u003e\u0026lt;\u003cspan style=\"color:#f92672\"\u003escript\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003esrc\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;https://cdn.jsdelivr.net/npm/hls.js@latest\u0026#34;\u003c/span\u003e\u0026gt;\u0026lt;/\u003cspan style=\"color:#f92672\"\u003escript\u003c/span\u003e\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eAfter that, we have the implementation. Here, we start with a working \u003ccode\u003e\u0026lt;video\u0026gt;\u003c/code\u003e element, then use JavaScript to swap over to HLS.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4\"\u003e\u003ccode class=\"language-javascript\" data-lang=\"javascript\"\u003e(() =\u0026gt; {\n  \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;use strict\u0026#39;\u003c/span\u003e;\n\n  \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (\u003cspan style=\"color:#a6e22e\"\u003eHls\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eisSupported\u003c/span\u003e()) {\n    \u003cspan style=\"color:#66d9ef\"\u003elet\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eselector\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;video source[type=\u0026#39;application/vnd.apple.mpegurl\u0026#39;]\u0026#34;\u003c/span\u003e,\n        \u003cspan style=\"color:#a6e22e\"\u003evideoSources\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e document.\u003cspan style=\"color:#a6e22e\"\u003equerySelectorAll\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003eselector\u003c/span\u003e);\n\n    \u003cspan style=\"color:#a6e22e\"\u003evideoSources\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eforEach\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003evideoSource\u003c/span\u003e =\u0026gt; {\n      \u003cspan style=\"color:#66d9ef\"\u003elet\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003em3u8\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003evideoSource\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003esrc\u003c/span\u003e,\n          \u003cspan style=\"color:#a6e22e\"\u003eonce\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003efalse\u003c/span\u003e;\n\n      \u003cspan style=\"color:#75715e\"\u003e// Clone the video to remove any source\n\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e      \u003cspan style=\"color:#66d9ef\"\u003elet\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eoldVideo\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003evideoSource\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eparentNode\u003c/span\u003e,\n          \u003cspan style=\"color:#a6e22e\"\u003enewVideo\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eoldVideo\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003ecloneNode\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003efalse\u003c/span\u003e);\n\n      \u003cspan style=\"color:#75715e\"\u003e// Replace video tag with our clone.\n\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e      \u003cspan style=\"color:#a6e22e\"\u003eoldVideo\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eparentNode\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003ereplaceChild\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003enewVideo\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003eoldVideo\u003c/span\u003e);\n\n      \u003cspan style=\"color:#75715e\"\u003e// On play, initialize hls.js, once.\n\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e      \u003cspan style=\"color:#a6e22e\"\u003enewVideo\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eaddEventListener\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;play\u0026#39;\u003c/span\u003e, () =\u0026gt; {\n        \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (\u003cspan style=\"color:#a6e22e\"\u003eonce\u003c/span\u003e) {\n          \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e;\n        };\n        \u003cspan style=\"color:#a6e22e\"\u003eonce\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003etrue\u003c/span\u003e;\n\n        \u003cspan style=\"color:#66d9ef\"\u003evar\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ehls\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003enew\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eHls\u003c/span\u003e({\n          \u003cspan style=\"color:#a6e22e\"\u003ecapLevelToPlayerSize\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e:\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003efalse\u003c/span\u003e\n        });\n        \u003cspan style=\"color:#a6e22e\"\u003ehls\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eattachMedia\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003enewVideo\u003c/span\u003e);\n        \u003cspan style=\"color:#a6e22e\"\u003ehls\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eloadSource\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003em3u8\u003c/span\u003e);\n        \u003cspan style=\"color:#a6e22e\"\u003ehls\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eon\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003eHls\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eEvents\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eMANIFEST_PARSED\u003c/span\u003e, (\u003cspan style=\"color:#a6e22e\"\u003eevent\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003edata\u003c/span\u003e) =\u0026gt; {\n          \u003cspan style=\"color:#a6e22e\"\u003enewVideo\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eplay\u003c/span\u003e();\n        });\n      }, \u003cspan style=\"color:#66d9ef\"\u003efalse\u003c/span\u003e);\n    });\n  }\n})();\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"cors\"\u003eCORS\u003c/h3\u003e\n\u003cp\u003eIf you are serving the files from a third-party host (such as Amazon S3), you will need to enable \u003ca href=\"https://caniuse.com/#search=cors\"\u003eCORS\u003c/a\u003e support on your bucket.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4\"\u003e\u003ccode class=\"language-xml\" data-lang=\"xml\"\u003e\u003cspan style=\"color:#75715e\"\u003e\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt;\u003c/span\u003e\n\u003cspan style=\"color:#f92672\"\u003e\u0026lt;CORSConfiguration\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003exmlns=\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;http://s3.amazonaws.com/doc/2006-03-01/\u0026#34;\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e\n  \u003cspan style=\"color:#f92672\"\u003e\u0026lt;CORSRule\u0026gt;\u003c/span\u003e\n    \u003cspan style=\"color:#f92672\"\u003e\u0026lt;AllowedHeader\u0026gt;\u003c/span\u003e*\u003cspan style=\"color:#f92672\"\u003e\u0026lt;/AllowedHeader\u0026gt;\u003c/span\u003e\n    \u003cspan style=\"color:#f92672\"\u003e\u0026lt;AllowedOrigin\u0026gt;\u003c/span\u003e*\u003cspan style=\"color:#f92672\"\u003e\u0026lt;/AllowedOrigin\u0026gt;\u003c/span\u003e\n    \u003cspan style=\"color:#f92672\"\u003e\u0026lt;AllowedMethod\u0026gt;\u003c/span\u003eGET\u003cspan style=\"color:#f92672\"\u003e\u0026lt;/AllowedMethod\u0026gt;\u003c/span\u003e\n    \u003cspan style=\"color:#f92672\"\u003e\u0026lt;AllowedMethod\u0026gt;\u003c/span\u003eHEAD\u003cspan style=\"color:#f92672\"\u003e\u0026lt;/AllowedMethod\u0026gt;\u003c/span\u003e\n  \u003cspan style=\"color:#f92672\"\u003e\u0026lt;/CORSRule\u0026gt;\u003c/span\u003e\n\u003cspan style=\"color:#f92672\"\u003e\u0026lt;/CORSConfiguration\u0026gt;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eAdditionally, if you have a CDN cache in front of that S3 bucket (e.g., Amazon CloudFront), you\u0026rsquo;ll need to make sure that it is configured to allow the \u003ccode\u003eOrigin\u003c/code\u003e headers through and also respond to the HTTP \u003ccode\u003eOPTIONS\u003c/code\u003e verb.\u003c/p\u003e\n\u003cp\u003eYou can find more information about solving this problem with CloudFront at “\u003ca href=\"https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/header-caching.html#header-caching-web-cors\"\u003eConfiguring CloudFront to Respect CORS Settings\u003c/a\u003e”.\u003c/p\u003e\n\u003cscript src=\"https://cdn.jsdelivr.net/npm/hls.js@latest\"\u003e\u003c/script\u003e\n\u003cscript type=\"text/javascript\" src=\"https://ryanparman.com/js/stream-hls.min.270faa3c315322e584846228fe3da0897e67544a45ac2646b9050c886baa54b9.js\" integrity=\"sha256-Jw\u0026#43;qPDFTIuWEhGIo/j2giX5nVEpFrCZGuQUMiGuqVLk=\"\u003e\u003c/script\u003e\n\n",
        "plain":"While YouTube is free (as in money) to use, the cost is paid in terms of privacy and advertising analytics. So I've decided to investigate self-hosting my video content. The Cost of YouTube With YouTube, you sacrifice privacy in favor of cost. YouTube is the very best at what they do (serve video to all resolutions and bandwidths), and they are backed by Google who is the very best at what they do (collect data in order to facilitate selling a primed audience to advertisers).\n  There’s nothing inherently wrong with that. We live in a capitalistic society; there is money to be made; Google/YouTube is providing a service to advertisers; many consumers will (knowingly or unknowingly) give up their privacy in exchange for free-as-in-money services.\nBut as I\u0026rsquo;ve gotten older and started to realize just how much data Google has on each and every one of us, I\u0026rsquo;ve started valuing my privacy a lot more. I\u0026rsquo;d like to provide an option for you to protect your privacy as well.\nSelf-Hosting Video Content Even with efficient video codecs, video can still cost a lot of money to serve.\nMany websites provide a video to their users, wherein this video is a single file, and the browser will begin loading and playing the video from start to finish. This means that even if the user only watches the first few seconds of a 5 minute video, it\u0026rsquo;s possible that the video is downloaded in its entirety — which is an unnecessary cost.\nHowever, we can provide a better user experience as well as reduce hosting costs by leveraging the ability to serve bandwidth-adaptive chunks of video to players on-demand.\nAdaptive Bitrate Streaming There are two major, semi-compatible approaches to adaptive bitrate streaming over HTTP. One is called HTTP Live Streaming (“HLS”), and the other is called Dynamic Adaptive Streaming over HTTP (“MPEG-DASH”).\n  From Wikipedia:\n Adaptive bitrate streaming is a technique used in streaming multimedia over computer networks. While in the past most video or audio streaming technologies utilized streaming protocols such as RTP with RTSP, today\u0026rsquo;s adaptive streaming technologies are almost exclusively based on HTTP and designed to work efficiently over large distributed HTTP networks such as the Internet.\nIt works by detecting a user\u0026rsquo;s bandwidth and CPU capacity in real time and adjusting the quality of the media stream accordingly. It requires the use of an encoder which can encode a single source media (video or audio) at multiple bit rates. The player client switches between streaming the different encodings depending on available resources. \u0026ldquo;The result: very little buffering, fast start time and a good experience for both high-end and low-end connections.\u0026rdquo; […]\nHTTP-based adaptive bitrate streaming technologies yield additional benefits over traditional server-driven adaptive bitrate streaming. First, since the streaming technology is built on top of HTTP, contrary to RTP-based adaptive streaming, the packets have no difficulties traversing firewall and NAT devices. Second, since HTTP streaming is purely client-driven, all adaptation logic resides at the client. This reduces the requirement of persistent connections between server and client application. Furthermore, the server is not required to maintain session state information on each client, increasing scalability. Finally, existing HTTP delivery infrastructure, such as HTTP caches and servers can be seamlessly adopted.\nA scalable CDN is used to deliver media streaming to an Internet audience. The CDN receives the stream from the source at its Origin server, then replicates it to many or all of its Edge cache servers. The end-user requests the stream and is redirected to the \u0026ldquo;closest\u0026rdquo; Edge server. […] The use of HTTP-based adaptive streaming allows the Edge server to run a simple HTTP server software, whose licence cost is cheap or free, reducing software licensing cost, compared to costly media server licences (e.g. Adobe Flash Media Streaming Server). The CDN cost for HTTP streaming media is then similar to HTTP web caching CDN cost.\n This means that we can use off-the-shelf services like Amazon S3 and Amazon CloudFront to serve video, which are relatively inexpensive and have large user-bases who can answer questions when you run into issues.\nHTTP Live Streaming (HLS) After doing some research, I came across a blog post that was particularly helpful — “Self-hosted videos with HLS” by Vincent Bernat.\nVincent writes:\n To serve HLS videos, you need three kinds of files:\n the media segments (encoded with different bitrates/resolutions), a media playlist for each variant, listing the media segments, and a master playlist, listing the media playlists.  Media segments can come in two formats:\n MPEG-2 Transport Streams (TS), or Fragmented MP4.  Fragmented MP4 media segments are supported since iOS 10. They are a bit more efficient and can be reused to serve the same content as MPEG-DASH (only the playlists are different). Also, they can be served from the same file with range requests. However, if you want to target older versions of iOS, you need to stick with MPEG-2 TS.\n At the time of this writing, iOS 12 will be out in a week or two. A quick search tells me that iOS 10 and newer make up 85% of all iOS users. This means that I can pretty safely use the Fragmented MP4 method which, according to these sources, is more compatible with MPEG-DASH for some cross-over implementations in the future.\nSample Video  Source: Hallelujah - Brooklyn Duo (Piano \u0026#43; Cello)\nImplementation Encoding and Deploying Video Vincent Bernat provides a tool on GitHub which greatly simplifies the process of creating the various video fragments called video2hls.\nFor this website, I have put together a workflow for creating and serving HLS video content.\n  I use H.264 video with AAC audio wrapped inside an MP4 container, exclusively. These are all defined as part of the MPEG-4 specification, and is the best-supported grouping of codecs and containers across all browsers and devices.\nHardware-level decoders are commonplace inside computers, phones, tablets, and set-top boxes like Xbox, PlayStation, and Apple TV.\n  I have a directory called streaming-video, which is separate from the images that I use and push to S3. Video files are large, and I don\u0026rsquo;t want to accidentally push partially-completed video data to my caching CDN before they\u0026rsquo;re ready.\n  I have a command which takes any video file inside the streaming-video folder, with a filename ending in -source.mp4, and passes it through video2hls, creating a folder called {video}.fmp4 which contains all of the video and playlist files I need across a large variety of bandwidths and resolutions.\nIt will only do the work to create the directory and all of the fragmented files if the directory doesn\u0026rsquo;t already exist.\nfind ./streaming-video -type f -name \u0026#34;*-source.mp4\u0026#34; | xargs -I {} \\  bash -c \u0026#39;if [ ! -d \u0026#34;${1%-source.mp4}.fmp4\u0026#34; ]; then \\ video2hls --debug --output \u0026#34;${1%-source.mp4}.fmp4\u0026#34; --hls-type fmp4 \u0026#34;$1\u0026#34;; \\ fi;\u0026#39; _ {} \\;   I find all of the .m3u8 playlist files and gzip them (since they\u0026rsquo;re just text). This is essentially an in-place rewrite of the files.\nfind ./streaming-video -type f -name \u0026#34;*.m3u8\u0026#34; | xargs -P 8 -I {} \\  bash -c \u0026#39;! gunzip -t $1 2\u0026gt;/dev/null \u0026amp;\u0026amp; gzip -v $1 \u0026amp;\u0026amp; mv -v $1.gz $1;\u0026#39; _ {} \\;   Lastly, I push all of the files up to the hls folder in my S3 bucket using the AWS Unified CLI Tools, setting the correct Content-Type and Content-Encoding headers.\n# The .m3u8 playlists that we gzipped aws s3 sync ./streaming-video s3://blog.ryanparman.com/hls \\  --exclude \u0026#39;*.*\u0026#39; \\  --include \u0026#39;*.m3u8\u0026#39; \\  --acl=public-read \\  --cache-control max-age=31536000,public \\  --content-type \u0026#39;application/vnd.apple.mpegurl\u0026#39; \\  --content-encoding \u0026#39;gzip\u0026#39; # The video \u0026#34;posters\u0026#34; aws s3 sync ./streaming-video s3://blog.ryanparman.com/hls \\  --exclude \u0026#39;*.*\u0026#39; \\  --include \u0026#39;*.jpg\u0026#39; \\  --acl=public-read \\  --cache-control max-age=31536000,public \\  --content-type \u0026#39;image/jpeg\u0026#39; # The fragmented MP4 files aws s3 sync ./streaming-video s3://blog.ryanparman.com/hls \\  --exclude \u0026#39;*.*\u0026#39; \\  --include \u0026#39;*.mp4\u0026#39; \\  --acl=public-read \\  --cache-control max-age=31536000,public \\  --content-type \u0026#39;video/mp4\u0026#39;   The Client-Side Code After pushing the content to our CDN, we can use the standard HTML5 \u0026lt;video\u0026gt; tag to tell browsers how to load the requested assets.\n\u0026lt;video poster=\u0026#34;https://cdn.ryanparman.com/hls/hallelujah.fmp4/poster.jpg\u0026#34; controls preload=\u0026#34;none\u0026#34;\u0026gt; \u0026lt;source src=\u0026#34;https://cdn.ryanparman.com/hls/hallelujah.fmp4/index.m3u8\u0026#34; type=\u0026#34;application/vnd.apple.mpegurl\u0026#34;\u0026gt; \u0026lt;source src=\u0026#34;https://cdn.ryanparman.com/hls/hallelujah.fmp4/progressive.mp4\u0026#34; type=\u0026#39;video/mp4; codecs=\u0026#34;avc1.4d401f, mp4a.40.2\u0026#34;\u0026#39;\u0026gt; \u0026lt;/video\u0026gt;   Here, we have a static poster image that the \u0026lt;video\u0026gt; element loads by default.\n  Next, we have an HLS-compatible playlist file (.m3u8), which ultimately points to the correct .mp4 files.\n  Lastly, we have a standard .mp4 fallback.\n  Enabling Chrome, Firefox, and Edge using hls.js Dailymotion has released a JavaScript library called hls.js which enables HLS playback on browsers like Chrome, Firefox, and Edge using Fragmented MP4 sources.\nYou can load the script from the CDN:\n\u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/hls.js@latest\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; After that, we have the implementation. Here, we start with a working \u0026lt;video\u0026gt; element, then use JavaScript to swap over to HLS.\n(() =\u0026gt; { \u0026#39;use strict\u0026#39;; if (Hls.isSupported()) { let selector = \u0026#34;video source[type=\u0026#39;application/vnd.apple.mpegurl\u0026#39;]\u0026#34;, videoSources = document.querySelectorAll(selector); videoSources.forEach(videoSource =\u0026gt; { let m3u8 = videoSource.src, once = false; // Clone the video to remove any source  let oldVideo = videoSource.parentNode, newVideo = oldVideo.cloneNode(false); // Replace video tag with our clone.  oldVideo.parentNode.replaceChild(newVideo, oldVideo); // On play, initialize hls.js, once.  newVideo.addEventListener(\u0026#39;play\u0026#39;, () =\u0026gt; { if (once) { return; }; once = true; var hls = new Hls({ capLevelToPlayerSize: false }); hls.attachMedia(newVideo); hls.loadSource(m3u8); hls.on(Hls.Events.MANIFEST_PARSED, (event, data) =\u0026gt; { newVideo.play(); }); }, false); }); } })(); CORS If you are serving the files from a third-party host (such as Amazon S3), you will need to enable CORS support on your bucket.\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;CORSConfiguration xmlns=\u0026#34;http://s3.amazonaws.com/doc/2006-03-01/\u0026#34;\u0026gt; \u0026lt;CORSRule\u0026gt; \u0026lt;AllowedHeader\u0026gt;*\u0026lt;/AllowedHeader\u0026gt; \u0026lt;AllowedOrigin\u0026gt;*\u0026lt;/AllowedOrigin\u0026gt; \u0026lt;AllowedMethod\u0026gt;GET\u0026lt;/AllowedMethod\u0026gt; \u0026lt;AllowedMethod\u0026gt;HEAD\u0026lt;/AllowedMethod\u0026gt; \u0026lt;/CORSRule\u0026gt; \u0026lt;/CORSConfiguration\u0026gt; Additionally, if you have a CDN cache in front of that S3 bucket (e.g., Amazon CloudFront), you\u0026rsquo;ll need to make sure that it is configured to allow the Origin headers through and also respond to the HTTP OPTIONS verb.\nYou can find more information about solving this problem with CloudFront at “Configuring CloudFront to Respect CORS Settings”.\n  ",
        "source":"\n{{\u003cdescription\u003e}}\nWhile YouTube is free (as in money) to use, the cost is paid in terms of privacy and advertising analytics. So I've decided to investigate self-hosting my video content.\n{{\u003c/description\u003e}}\n\n## The Cost of YouTube\n\nWith YouTube, you sacrifice privacy in favor of cost. YouTube is the very best at what they do (serve video to all resolutions and bandwidths), and they are backed by Google who is the very best at what they do (collect data in order to facilitate selling a primed audience to advertisers).\n\n{{\u003cfullimage src=\"https://cdn.ryanparman.com/hugo/posts/2018/youtube-2017.png\"\u003e}}\n\nThere’s nothing inherently wrong with that. We live in a capitalistic society; there is money to be made; Google/YouTube is providing a service to advertisers; many consumers will (knowingly or unknowingly) give up their privacy in exchange for free-as-in-money services.\n\nBut as I've gotten older and started to realize just _how much_ data Google has on each and every one of us, I've started valuing my privacy a lot more. I'd like to provide an option for you to protect your privacy as well.\n\n## Self-Hosting Video Content\n\nEven with efficient video codecs, video can still cost a lot of money to serve.\n\nMany websites provide _a video_ to their users, wherein this video is a single file, and the browser will begin loading and playing the video from start to finish. This means that even if the user only watches the first few seconds of a 5 minute video, it's possible that the video is downloaded in its entirety — which is an unnecessary cost.\n\nHowever, we can provide a _better user experience_ as well as _reduce hosting costs_ by leveraging the ability to serve bandwidth-adaptive chunks of video to players on-demand.\n\n### Adaptive Bitrate Streaming\n\nThere are two major, semi-compatible approaches to [adaptive bitrate streaming](https://en.wikipedia.org/wiki/Adaptive_bitrate_streaming) over HTTP. One is called [HTTP Live Streaming]({{\u003c wayback \"https://en.wikipedia.org/wiki/HTTP_Live_Streaming\" \u003e}}) (“HLS”), and the other is called [Dynamic Adaptive Streaming over HTTP]({{\u003c wayback \"https://en.wikipedia.org/wiki/Dynamic_Adaptive_Streaming_over_HTTP\" \u003e}}) (“MPEG-DASH”).\n\n{{\u003cfullimage src=\"https://cdn.ryanparman.com/hugo/posts/2018/adaptive-bitrate-streaming.png\"\u003e}}\n\nFrom [Wikipedia]({{\u003c wayback \"https://en.wikipedia.org/wiki/Adaptive_bitrate_streaming\" \u003e}}):\n\n\u003e Adaptive bitrate streaming is a technique used in streaming multimedia over computer networks. While in the past most video or audio streaming technologies utilized streaming protocols such as RTP with RTSP, today's adaptive streaming technologies are almost exclusively based on HTTP and designed to work efficiently over large distributed HTTP networks such as the Internet.\n\u003e \n\u003e It works by detecting a user's bandwidth and CPU capacity in real time and adjusting the quality of the media stream accordingly. It requires the use of an encoder which can encode a single source media (video or audio) at multiple bit rates. The player client switches between streaming the different encodings depending on available resources. \"The result: very little buffering, fast start time and a good experience for both high-end and low-end connections.\" […]\n\u003e\n\u003e HTTP-based adaptive bitrate streaming technologies yield additional benefits over traditional server-driven adaptive bitrate streaming. First, since the streaming technology is built on top of HTTP, contrary to RTP-based adaptive streaming, the packets have no difficulties traversing firewall and NAT devices. Second, since HTTP streaming is purely client-driven, all adaptation logic resides at the client. This reduces the requirement of persistent connections between server and client application. Furthermore, the server is not required to maintain session state information on each client, increasing scalability. Finally, existing HTTP delivery infrastructure, such as HTTP caches and servers can be seamlessly adopted.\n\u003e\n\u003e A scalable CDN is used to deliver media streaming to an Internet audience. The CDN receives the stream from the source at its Origin server, then replicates it to many or all of its Edge cache servers. The end-user requests the stream and is redirected to the \"closest\" Edge server. […] The use of HTTP-based adaptive streaming allows the Edge server to run a simple HTTP server software, whose licence cost is cheap or free, reducing software licensing cost, compared to costly media server licences (e.g. Adobe Flash Media Streaming Server). The CDN cost for HTTP streaming media is then similar to HTTP web caching CDN cost.\n\nThis means that we can use off-the-shelf services like [Amazon S3](https://aws.amazon.com/s3) and [Amazon CloudFront](https://aws.amazon.com/cloudfront) to serve video, which are relatively inexpensive and have large user-bases who can answer questions when you run into issues.\n\n### HTTP Live Streaming (HLS)\n\nAfter doing some research, I came across a blog post that was particularly helpful — “[Self-hosted videos with HLS]({{\u003c wayback \"https://vincent.bernat.ch/en/blog/2018-self-hosted-videos\" \u003e}})” by Vincent Bernat.\n\nVincent writes:\n\n\u003e To serve HLS videos, you need three kinds of files:\n\u003e \n\u003e * the media segments (encoded with different bitrates/resolutions),\n\u003e * a media playlist for each variant, listing the media segments, and\n\u003e * a master playlist, listing the media playlists.\n\u003e \n\u003e Media segments can come in two formats:\n\u003e \n\u003e * MPEG-2 Transport Streams (TS), or\n\u003e * Fragmented MP4.\n\u003e \n\u003e Fragmented MP4 media segments are supported since iOS 10. They are a bit more efficient and can be reused to serve the same content as MPEG-DASH (only the playlists are different). Also, they can be served from the same file with range requests. However, if you want to target older versions of iOS, you need to stick with MPEG-2 TS.\n\nAt the time of this writing, iOS 12 will be out in a week or two. A quick search tells me that [iOS 10 and newer make up 85% of all iOS users]({{\u003c wayback \"https://data.apteligent.com/ios/\" \u003e}}). This means that I can pretty safely use the _Fragmented MP4_ method which, according to [these]({{\u003c wayback \"https://bitmovin.com/hls-news-wwdc-2016/\" \u003e}}) [sources]({{\u003c wayback \"http://www.streamingmedia.com/Articles/ReadArticle.aspx?ArticleID=111796\" \u003e}}), is more compatible with MPEG-DASH for some cross-over implementations in the future.\n\n## Sample Video\n\n{{\u003chls src=\"hallelujah\"\n       sourceUrl=\"https://youtu.be/e1C9kpMV2e8\"\n       sourceTitle=\"Hallelujah - Brooklyn Duo (Piano + Cello)\"\n\u003e}}\n\n## Implementation\n\n### Encoding and Deploying Video\n\nVincent Bernat provides a tool on GitHub which greatly simplifies the process of creating the various video fragments called [video2hls]({{\u003c wayback \"https://github.com/vincentbernat/video2hls\" \u003e}}).\n\nFor [this website](https://github.com/skyzyx/blog/blob/master/Makefile), I have put together a workflow for creating and serving HLS video content.\n\n1. I use **H.264** video with **AAC** audio wrapped inside an **MP4** container, _exclusively_. These are all defined as part of the MPEG-4 specification, and is the [best-supported grouping of codecs and containers across all browsers and devices](https://caniuse.com/#search=H.264).\n\n    Hardware-level decoders are commonplace inside computers, phones, tablets, and set-top boxes like Xbox, PlayStation, and Apple TV.\n\n1. I have a directory called `streaming-video`, which is separate from the images that I use and push to S3. Video files are large, and I don't want to accidentally push partially-completed video data to my caching CDN before they're ready.\n\n1. I have a command which takes any video file inside the `streaming-video` folder, with a filename ending in `-source.mp4`, and passes it through `video2hls`, creating a folder called `{video}.fmp4` which contains all of the video and playlist files I need across a large variety of bandwidths and resolutions.\n\n    It will only do the work to create the directory and all of the fragmented files if the directory doesn't already exist.\n\n    ```bash\n    find ./streaming-video -type f -name \"*-source.mp4\" | xargs -I {} \\\n        bash -c 'if [ ! -d \"${1%-source.mp4}.fmp4\" ]; then \\\n            video2hls --debug --output \"${1%-source.mp4}.fmp4\" --hls-type fmp4 \"$1\"; \\\n        fi;' _ {} \\;\n    ```\n\n1. I find all of the `.m3u8` playlist files and gzip them (since they're just text). This is essentially an in-place rewrite of the files.\n\n    ```bash\n    find ./streaming-video -type f -name \"*.m3u8\" | xargs -P 8 -I {} \\\n        bash -c '! gunzip -t $1 2\u003e/dev/null \u0026\u0026 gzip -v $1 \u0026\u0026 mv -v $1.gz $1;' _ {} \\;\n    ```\n\n1. Lastly, I push all of the files up to the `hls` folder in my S3 bucket using the [AWS Unified CLI Tools](https://github.com/aws/aws-cli), setting the correct `Content-Type` and `Content-Encoding` headers.\n\n    ```bash\n    # The .m3u8 playlists that we gzipped\n    aws s3 sync ./streaming-video s3://blog.ryanparman.com/hls \\\n        --exclude '*.*' \\\n        --include '*.m3u8' \\\n        --acl=public-read \\\n        --cache-control max-age=31536000,public \\\n        --content-type 'application/vnd.apple.mpegurl' \\\n        --content-encoding 'gzip'\n\n    # The video \"posters\"\n    aws s3 sync ./streaming-video s3://blog.ryanparman.com/hls \\\n        --exclude '*.*' \\\n        --include '*.jpg' \\\n        --acl=public-read \\\n        --cache-control max-age=31536000,public \\\n        --content-type 'image/jpeg'\n\n    # The fragmented MP4 files\n    aws s3 sync ./streaming-video s3://blog.ryanparman.com/hls \\\n        --exclude '*.*' \\\n        --include '*.mp4' \\\n        --acl=public-read \\\n        --cache-control max-age=31536000,public \\\n        --content-type 'video/mp4'\n    ```\n\n### The Client-Side Code\n\nAfter pushing the content to our CDN, we can use the standard HTML5 `\u003cvideo\u003e` tag to tell browsers how to load the requested assets.\n\n```html\n\u003cvideo poster=\"https://cdn.ryanparman.com/hls/hallelujah.fmp4/poster.jpg\" controls preload=\"none\"\u003e\n    \u003csource src=\"https://cdn.ryanparman.com/hls/hallelujah.fmp4/index.m3u8\" type=\"application/vnd.apple.mpegurl\"\u003e\n    \u003csource src=\"https://cdn.ryanparman.com/hls/hallelujah.fmp4/progressive.mp4\" type='video/mp4; codecs=\"avc1.4d401f, mp4a.40.2\"'\u003e\n\u003c/video\u003e\n```\n\n1. Here, we have a static _poster_ image that the `\u003cvideo\u003e` element loads by default.\n\n1. Next, we have an HLS-compatible playlist file (`.m3u8`), which ultimately points to the correct `.mp4` files.\n\n1. Lastly, we have a standard `.mp4` fallback.\n\n### Enabling Chrome, Firefox, and Edge using hls.js\n\nDailymotion has released a JavaScript library called [hls.js](https://github.com/video-dev/hls.js) which enables HLS playback on browsers like Chrome, Firefox, and Edge using Fragmented MP4 sources.\n\nYou can load the script from the CDN:\n\n```html\n\u003cscript src=\"https://cdn.jsdelivr.net/npm/hls.js@latest\"\u003e\u003c/script\u003e\n```\n\nAfter that, we have the implementation. Here, we start with a working `\u003cvideo\u003e` element, then use JavaScript to swap over to HLS.\n\n```javascript\n(() =\u003e {\n  'use strict';\n\n  if (Hls.isSupported()) {\n    let selector = \"video source[type='application/vnd.apple.mpegurl']\",\n        videoSources = document.querySelectorAll(selector);\n\n    videoSources.forEach(videoSource =\u003e {\n      let m3u8 = videoSource.src,\n          once = false;\n\n      // Clone the video to remove any source\n      let oldVideo = videoSource.parentNode,\n          newVideo = oldVideo.cloneNode(false);\n\n      // Replace video tag with our clone.\n      oldVideo.parentNode.replaceChild(newVideo, oldVideo);\n\n      // On play, initialize hls.js, once.\n      newVideo.addEventListener('play', () =\u003e {\n        if (once) {\n          return;\n        };\n        once = true;\n\n        var hls = new Hls({\n          capLevelToPlayerSize: false\n        });\n        hls.attachMedia(newVideo);\n        hls.loadSource(m3u8);\n        hls.on(Hls.Events.MANIFEST_PARSED, (event, data) =\u003e {\n          newVideo.play();\n        });\n      }, false);\n    });\n  }\n})();\n```\n\n### CORS\n\nIf you are serving the files from a third-party host (such as Amazon S3), you will need to enable [CORS](https://caniuse.com/#search=cors) support on your bucket.\n\n```xml\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e\n\u003cCORSConfiguration xmlns=\"http://s3.amazonaws.com/doc/2006-03-01/\"\u003e\n  \u003cCORSRule\u003e\n    \u003cAllowedHeader\u003e*\u003c/AllowedHeader\u003e\n    \u003cAllowedOrigin\u003e*\u003c/AllowedOrigin\u003e\n    \u003cAllowedMethod\u003eGET\u003c/AllowedMethod\u003e\n    \u003cAllowedMethod\u003eHEAD\u003c/AllowedMethod\u003e\n  \u003c/CORSRule\u003e\n\u003c/CORSConfiguration\u003e\n```\n\nAdditionally, if you have a CDN cache in front of that S3 bucket (e.g., Amazon CloudFront), you'll need to make sure that it is configured to allow the `Origin` headers through and also respond to the HTTP `OPTIONS` verb.\n\nYou can find more information about solving this problem with CloudFront at “[Configuring CloudFront to Respect CORS Settings]({{\u003c wayback \"https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/header-caching.html#header-caching-web-cors\" \u003e}})”.\n\n\u003cscript src=\"https://cdn.jsdelivr.net/npm/hls.js@latest\"\u003e\u003c/script\u003e\n{{\u003cscript src=\"/js/stream-hls.js\"\u003e}}\n"},
    "links": {
        "prev": {"title": "Clueless Recruiters, Issue #8", "permalink": "https://ryanparman.com/posts/2018/clueless-recruiters-issue-8/"},
        "next": {"title": "The Hiring Process, Part I", "permalink": "https://ryanparman.com/posts/2018/the-hiring-process-part-i-what-i-look-for-in-a-cv-resume-remastered/"},
        "ignore": "me"
    }
}

            
        ]
    }
}
